\documentclass[UTF8,a4paper,12pt]{ctexbook} 

\usepackage{graphicx}%学习插入图
\usepackage{verbatim}%学习注释多行
\usepackage{booktabs}%表格
\usepackage{longtable} 
\usepackage{geometry}%图片
\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{listings}%代码
\usepackage{xcolor}  %颜色
\usepackage{enumitem}%列表格式
\setenumerate[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setitemize[1]{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}
\setdescription{itemsep=0pt,partopsep=0pt,parsep=\parskip,topsep=5pt}

\usepackage{tcolorbox}
\usepackage{algorithm}  %format of the algorithm
\usepackage{algorithmic}%format of the algorithm
\usepackage{multirow}   %multirow for format of table
\usepackage{tabularx} 	%表格排版格式控制
\usepackage{array}	%表格排版格式控制
\usepackage{hyperref}

\CTEXsetup[format+={\flushleft}]{section}
%%%% 下面的命令添加新字体 %%%%%


%%%%%% 设置字号 %%%%%%
\newcommand{\chuhao}{\fontsize{42pt}{\baselineskip}\selectfont}
\newcommand{\xiaochuhao}{\fontsize{36pt}{\baselineskip}\selectfont}
\newcommand{\yihao}{\fontsize{28pt}{\baselineskip}\selectfont}
\newcommand{\erhao}{\fontsize{21pt}{\baselineskip}\selectfont}
\newcommand{\xiaoerhao}{\fontsize{18pt}{\baselineskip}\selectfont}
\newcommand{\sanhao}{\fontsize{15.75pt}{\baselineskip}\selectfont}
\newcommand{\sihao}{\fontsize{14pt}{\baselineskip}\selectfont}
\newcommand{\xiaosihao}{\fontsize{12pt}{\baselineskip}\selectfont}
\newcommand{\wuhao}{\fontsize{10.5pt}{\baselineskip}\selectfont}
\newcommand{\xiaowuhao}{\fontsize{9pt}{\baselineskip}\selectfont}
\newcommand{\liuhao}{\fontsize{7.875pt}{\baselineskip}\selectfont}
\newcommand{\qihao}{\fontsize{5.25pt}{\baselineskip}\selectfont}

%%%% 段落首行缩进两个字 %%%%
\makeatletter
\let\@afterindentfalse\@afterindenttrue
\@afterindenttrue
\makeatother
\setlength{\parindent}{2em}  %中文缩进两个汉字位


%%%% 下面的命令重定义页面边距，使其符合中文刊物习惯 %%%%
\addtolength{\topmargin}{-54pt}
\setlength{\oddsidemargin}{0.63cm}  % 3.17cm - 1 inch
\setlength{\evensidemargin}{\oddsidemargin}
\setlength{\textwidth}{14.66cm}
\setlength{\textheight}{24.00cm}    % 24.62

%%%% 下面的命令设置行间距与段落间距 %%%%
\linespread{1.4}
\setlength{\parskip}{0.5\baselineskip}

%%%% 下面的命令定义图表、算法、公式 %%%%
\newcommand{\EQ}[1]{$\textbf{EQ:}#1\ $}
\newcommand{\ALGORITHM}[1]{$\textbf{Algorithm:}#1\ $}
\newcommand{\Figure}[1]{$\textbf{Figure }#1\ $}

%%%% 下面命令改变图表下标题的前缀 %%%%% 如:图-1、Fig-1
\renewcommand{\figurename}{Fig}

\geometry{left=1.6cm,right=1.8cm,top=2cm,bottom=1.7cm} %设置文章宽度

\pagestyle{plain} 		  %设置页面布局

%代码效果定义
\definecolor{mygreen}{rgb}{0,0.6,0}
\definecolor{mygray}{rgb}{0.5,0.5,0.5}
\definecolor{mymauve}{rgb}{0.58,0,0.82}
\lstset{ %
	backgroundcolor=\color{white},   % choose the background color
	basicstyle=\footnotesize\ttfamily,        % size of fonts used for the code
	columns=fullflexible,
	breaklines=true,                 % automatic line breaking only at whitespace
	captionpos=b,                    % sets the caption-position to bottom
	tabsize=4,
	commentstyle=\color{mygreen},    % comment style
	escapeinside={\%*}{*)},          % if you want to add LaTeX within your code
	keywordstyle=\color{blue},       % keyword style
	stringstyle=\color{mymauve}\ttfamily,     % string literal style
	frame=single,					%tb top and bottom; L left double line
	xleftmargin=.06\textwidth, 
	%xrightmargin=.1\textwidth,
	rulesepcolor=\color{red!20!green!20!blue!20},
	% identifierstyle=\color{red},
	language=c++,
}
\setcounter{tocdepth}{4}	
\author{\kaishu 郑华}
\title{\heiti Linux 学习笔记}

\begin{document}          %正文排版开始
 	\maketitle
 	\tableofcontents
 	
 \chapter{Linux 基本知识} 
	 \section{基本技能}
		 正如你所见，Linux发行版并非Linux，Linux仅是指操作系统的内核。

		 \subsection{推荐的发行版}
		 \begin{itemize}
			 \item UBUNTU 适合纯菜鸟，追求稳定的官方支持，对系统稳定性要求较弱，喜欢最新应用，相对来说不太喜欢折腾的开发者。
			 \item Debian，相对UBUNTU难很多的发行版，突出特点是稳定与容易使用的包管理系统，缺点是企业支持不足，为社区开发驱动。
			 \item Arch，追逐时尚的开发者的首选，优点是包更新相当快，无缝升级，一次安装基本可以一直运作下去，没有如UBUNTU那样的版本概念，说的专业点叫滚动升级，保持你的系统一定是最新的。缺点显然易见，不稳定。同时安装配置相对Debian再麻烦点。
			 \item Gentoo，相对Arch再难点，考验使用者的综合水平，从系统安装到微调，内核编译都亲历亲为，是高手及黑客显示自己技术手段，按需配置符合自己要求的系统的首选。
			 \item Slackware与Gentoo类似。
			 \item CentOS，社区维护的RedHat的复刻版本，完全使用RedHat的源码重新编译生成，与RedHat的兼容性在理论上来说是最好的。如果你专注于Linux服务器，如网络管理，架站，那么CentOS是你的选择。
			 \item LFS，终极黑客显摆工具，完全从源代码安装，编译系统。安装前你得到的只有一份文档，你要做的就是照文档你的说明，一步步，一条条命令，一个个软件包的去构建你的Linux，完全由你自己控制，想要什么就是什么。如果你做出了LFS，证明你的Linux功底已经相当不错，如果你能拿LFS文档活学活用，再将Linux从源代码开始移植到嵌入式系统，我敢说中国的企业你可以混的很好。 
		\end{itemize}
		
		\subsection{Linux基础}
			你得挑一个适合你的系统，然后在虚拟机安装它，开始使用它。 如果你想快速学会Linux，我有一个建议就是\textbf{忘记图形界面}，不要想图形界面能不能提供你问题的答案， \textbf{而是满世界的去找，去问，如何用命令行解决你的问题}。
			
			在这个过程中，你最好能将Linux的命令掌握的不错，起码常用的命令得知道，同时建立了自己的知识库， 里面是你积累的各项知识。
		
		\subsection{Linux 平台C++ 开发}
			你需要学习的是Linux平台的C/C++开发，同时还有Bash脚本编程，如果你对Java兴趣很深还有Java。 同样，建议你抛弃掉图形界面的IDE，从VIM开始，为什么是VIM，而不是Emacs， 我无意挑起编辑器大战，但我觉得VIM适合初学者，适合手比较笨，脑袋比较慢的开发者。 Emacs的键位太多，太复杂，我很畏惧。然后是GCC，Make，Eclipse（Java，C++或者）。
			
			虽然将C++列在了Eclipse中，但我并不推荐用IDE开发C++，因为这不是Linux的文化， 容易让你忽略一些你应该注意的问题。 IDE让你变懒，懒得跟猪一样。如果你对程序调试，测试工作很感兴趣，\textbf{GDB也得学的很好}， 如果不是GDB也是必修课。这是开发的第一步，注意我并没有提过一句Linux系统API的内容， 这个阶段也不要关心这个。你要做的就是积累经验，在Linux平台的开发经验。
			
			我推荐的书如下：C语言程序设计。 C语言，白皮书当然更好。 C++推荐 C++ Primer Plus， Java我不喜欢，就不推荐了，附一个别人的书单：java 入门书籍。 工具方面推荐\textbf{VIM的官方手册}，\textbf{GCC中文文档}，\textbf{GDB中文文档}，\textbf{GNU开源软件开发指导}（电子书）， 汇编语言程序设计（让你对库，链接，内嵌汇编，编译器优化选项有初步了解，不必深度）。
			
			如果你这个阶段过不了就不必往下做了，这是底线，最基础的基础，否则离开，不要霍霍Linux开发。 不专业的Linux开发者作出的程序是与Linux文化或UNIX文化相背的，程序是走不远的， 不可能像Bash，VIM这些神品一样。 所以做不好干脆离开。
		
		\subsection{UNIX环境高级编程}
			UNIX环境高级编程堪称神作，经典中的经典。
			
			接下来进入Linux系统编程，不二选择，\textbf{APUE，UNIX环境高级编程}，一遍一遍的看， 看10遍都嫌少，如果你可以在大学将这本书翻烂，里面的内容都实践过，有作品，你口头表达能力够强， 你可以在面试时说服所有的考官。
			
			（可能有点夸张，但APUE绝对是圣经一般的读物，即使是Windows程序员也从其中汲取养分， Google创始人的案头书籍，扎尔伯克的床头读物。）
			
			这本书看完后你会对Linux系统编程有相当的了解，知道Linux与Windows平台间开发的差异在哪？ 它们的优缺点在哪？我的总结如下：做Windows平台开发，很苦，微软的系统API总在扩容， 想使用最新潮，最高效的功能，最适合当前流行系统的功能你必须时刻学习。 Linux不是，Linux系统的核心API就100来个，记忆力好完全可以背下来。 而且经久不变，为什么不变，因为要同UNIX兼容，符合POSIX标准。 所以Linux平台的开发大多是专注于底层的或服务器编程。
			
			这是其优点，当然图形是Linux的软肋，但我站在一个开发者的角度，我无所谓，因为命令行我也可以适应， 如果有更好的图形界面我就当作恩赐吧。另外，Windows闭源，系统做了什么你更本不知道， 永远被微软牵着鼻子跑，想想如果微软说Win8不支持QQ，那腾讯不得哭死。 而Linux完全开源，你不喜欢，可以自己改，只要你技术够。
			
			另外，Windows虽然使用的人多，但使用场合单一，专注与桌面。 而Linux在各个方面都有发展，尤其在云计算，服务器软件，嵌入式领域， 企业级应用上有广大前景，而且兼容性一流，由于支持POSIX可以无缝的运行在UNIX系统之上， 不管是苹果的Mac还是IBM的AS400系列，都是完全支持的。 另外，Linux的开发环境支持也绝对是一流的，不管是C/C++，Java，Bash，Python，PHP，Javascript，就连C\#也支持。而微软除Visual Stdio套件以外，都不怎么友好，不是吗？
			
			如果你看完APUE的感触有很多，希望验证你的某些想法或经验，推荐UNIX程序设计艺术， 世界顶级黑客将同你分享他的看法。

	\section{方向选择}			
		\subsection{网络方向}
			服务器软件编写及\textbf{高性能的并发程序}编写
			
			现在是时候做分流了。 大体上我分为四个方向：网络，图形，嵌入式，设备驱动。
			
			如果选择网络，再细分，我对其他的不是他熟悉，只说服务器软件编写及高性能的并发程序编写吧。 相对来说这是网络编程中技术含量最高的，也是底层的。 需要很多的经验，看很多的书，做很多的项目。
			
			我的看法是以下面的顺序来看书：
			\begin{enumerate}
				\item APUE再深读 – 尤其是进程，线程，IPC，套接字
				\item 多核程序设计 - Pthread一定得吃透了，你很NB
				\item UNIX网络编程 – 卷一，卷二
				\item TCP/IP网络详解 – 卷一 再看上面两本书时就该看了
				\item TCP/IP 网络详解 – 卷二 我觉得看到卷二就差不多了，当然卷三看了更好，努力，争取看了
				\item Lighttpd源代码 - 这个服务器也很有名了
				\item Nginx源代码 – 相较于Apache，Nginx的源码较少，如果能看个大致，很NB。看源代码主要是要学习里面的套接字编程及并发控制，想想都激动。如果你有这些本事，可以试着往暴雪投简历，为他们写服务器后台，想一想全球的魔兽都运行在你的服务器软件上。
				\item Linux内核 TCP/IP协议栈 – 深入了解TCP/IP的实现
			\end{enumerate}
			
			如果你还喜欢驱动程序设计，可以看看更底层的协议，如链路层的，写什么路由器，网卡， 网络设备的驱动及嵌入式系统软件应该也不成问题了。
			
			当然一般的网络公司，就算百度级别的也该毫不犹豫的雇用你。 只是看后面这些书需要时间与经验，所以35岁以前办到吧！跳槽到给你未来的地方！
			
		\subsection{图形方向}我觉得图形方向也是很有前途的，以下几个方面。
			\begin{enumerate}
				\item Opengl的工业及游戏开发，国外较成熟。
				\item 影视动画特效，如皮克斯，也是国外较成熟。
				\item GPU计算技术，可以应用在浏览器网页渲染上，GPU计算资源利用上，由于开源的原因，有很多的文档程序可以参考。如果能进火狐开发，或google做浏览器开发，应该会很好 。
			\end{enumerate}
			
		\subsection{嵌入式方向}嵌入式方向没说的，Linux很重要。
			
			掌握多个架构，不仅X86的，ARM的，单片机什么的也必须得懂。 硬件不懂我预见你会死在半路上，我也想走嵌入式方向，但我觉得就学校教授嵌入式的方法， 我连学电子的那帮学生都竞争不过。 奉劝大家，一定得懂硬件再去做，如果走到嵌入式应用开发，只能祝你好运， 不要碰上像Nokia，Hp这样的公司，否则你会很惨的。
			
		\subsection{驱动程序设计}	
			软件开发周期是很长的，硬件不同，很快。 每个月诞生那么多的新硬件，如何让他们在Linux上工作起来，这是你的工作。 由于Linux的兼容性很好，如果不是太低层的驱动，基本C语言就可以搞定，系统架构的影响不大， 因为有系统支持，你可能做些许更改就可以在ARM上使用PC的硬件了， 所以做硬件驱动开发不像嵌入式，对硬件知识的要求很高。
			
			可以从事的方向也很多，如家电啊，特别是如索尼，日立，希捷，富士康这样的厂子，很稀缺的。
		
	\section{硬件设备}
			在linux 系统中，每个设备都被当成一个文件来对待,如图\ref{Name_linux}。
			\begin{table}[H]
				\centering
				\begin{tabular}{p{8cm}<{\centering}|p{5cm}<{\centering}}
					\toprule[1.5pt]
						设备 &  设备在linux 中的文件名 \\
					\midrule
						SATA/USB硬盘/U盘 &  /dev/sd[a-p] \\
						当前鼠标 &  /dev/mouse \\
					\bottomrule[1.5pt]
				\end{tabular}
				\caption{设备文件名}
				\label{Name_linux}
			\end{table}
		\section{磁盘分区知识}
			 磁盘分区是使用分区编辑器(\verb|partition editor|) \textbf{在磁盘上}\textit{划分几个}\textbf{逻辑部分}。碟片一旦划分数个分区(\verb|Partition|),不同类的目录与文件可以存储进不同的分区。
			 
			 \subsection{分区类型}
				 \subparagraph{主分区}
					 主分区中不能再划分其他类型的分区，因此每个\textbf{主分区}都相当于\textbf{一个逻辑磁盘}（在这一点上主分区和逻辑分区很相似，但主分区是直接在硬盘上划分的，逻辑分区则必须建立于扩展分区中）
					 
				 \subparagraph{扩展分区}
					 最多只有1个，在使用MBR(主引导分区记录)方式下 主分区与扩展分区最多只能有4个，而且扩展分区不能写入数据，只能包含逻辑分区
					 
			\subsection{GUID}
	\section{裸机装机必备软件及技巧}
		\subparagraph{vim}必备，要么你修改配置文档都是个问题。
			通过wifi 先将基本的vim 搞定。
			
			\verb|sudo apt-get install vim|
			
			编程相关的插件到后续再安装。
			
		\subparagraph{网络配置}有网才能工作
			
			1.ln -s 创建快捷命令
			
			2.1配置IP(一般不动)
			\begin{itemize}[itemindent = 1em]
				\item \verb|vim /etc/network/interfaces|
				\item 根据情况确定用动态IP 还是静态IP 
				\begin{lstlisting}
#动态IP 
	auto eth0
	iface eth0 inet dhcp
	
#静态IP
	auto eth0
	iface eth0 inet static
	address xx.xx.xx.xx
	netmask xx.xx.xx.xx
	gateway xx.xx.xx.xx
				\end{lstlisting}
			\end{itemize}
			
			2.2配置DNS
			\begin{itemize}[itemindent = 1em]
				\item \verb|sudo vi /etc/resolv.conf|
				\item 添加\verb|nameserver 8.8.8.8 或 8.8.4.4|
				\item 重启网络：
				
				\verb|service networking restart|
				
				\verb|sudo /etc/init.d/networking restart|
			\end{itemize}
			
		\subparagraph{更新源}使用国内阿里云镜像，更快速度。

		\subparagraph{输入法}
			\begin{enumerate}[itemindent = 2em]
				\item \verb|sudo apt-get update|
				\item \verb|sudo apt-get install fcitx-googlepinyin|
				\item 注销或重启
				\item 找标题栏中的小企鹅，点开找配置fcitx
				\item 点\verb|+|,取消选中only.查找Google-pinyin
			\end{enumerate}	
					
		\subparagraph{文本工具Texlive与Texstudio}
		
		\subparagraph{git}	
		
		\subparagraph{网易云音乐}有音乐工作才有动力
			\begin{enumerate}[itemindent = 2em]
				\item 官网下载deb
				\item \verb|sudo dpkg -i ~/Downloads/xx.deb|
				\item 出现错误时\verb|sudo apt install -f|
				\item 再次运行安装命令
			\end{enumerate} 
		
		\subparagraph{vim 插件安装}
			\url{http://blog.csdn.net/lhf_tiger/article/details/7216500}
			
			\begin{enumerate}
				\item \verb|Ctags|:
					\verb|sudo apt-get install ctags|
					
					进入目录中
					\verb|ctags -R|
					
					
				\item \verb|Cscope|:
					\url{http://blog.csdn.net/av_geek/article/details/47976981}	
					
					\verb|sudo apt-get install cscope|
					
					\begin{itemize}
						\item 进入项目主目录 \verb|find . -name "*.h" -o -name "*.cc">cscope.files|
						\item 执行 \verb|cscope -bkq -i cscope.files|
						\item 执行 \verb|ctags -R|
						\item 进入要编辑的文件中\verb|:cs add cscope.out|
						\item 然后执行相应的命令 \verb@:cs find c|d|e|f|g|i|s|t name@
					\end{itemize}
			\end{enumerate}
		
 \chapter{命令相关}
	 命令格式：$$\verb|命令  [-选项]  [参数]|$$
	 
	 \begin{enumerate}[itemindent = 1em]
	 	\item 个别命令不遵循此格式
	 	\item 当有多个选项时，可以写在一起 \verb|ls -la 等价于 ls -l -a|
	 	\item 简化选项与完整选项 \verb|-a 等价于 --all|
	 \end{enumerate}
	\section{Linux系统} 
		\paragraph{X windows 与 Console}
			\begin{itemize}[itemindent = 1em]
				\item \verb|ctrl + alt + F1~F6|：Console 终端模式
				\item \verb|ctrl + alt + F7|：图形模式界面
			\end{itemize}
		
		\paragraph{目录结构}linux 目录如表\ref{mulu}所示。
			\begin{table}
				\caption{Linux 目录详解}
				\label{mulu}
				\begin{longtable}{l|m{14cm}}
					\hline
					目录 	   	   & 存放的内容类别\\
					\hline
							\verb|/ |   		&	文件系统的入口，\textbf{最高一级目录}			\\ 
							\verb|/bin| 		&	\textbf{基础系统所需要的命令位于此目录}，是最小系统所需要的命令，如：ls, cp, mkdir等。这个目录中的文件都是可执行的，一般的用户都可以使用。			\\
							\verb|/sbin|		&	多是涉及\textbf{系统管理的命令的存放，是超级权限用户root的可执行命令存放地}，\textit{普通用户无权限执行这个目录下的命令}；这个目录和/usr/sbin; /usr/X11R6/sbin或/usr/local/sbin 目录是相似的； 我们记住就行了，凡是目录sbin中包含的都是root权限才能执行的			\\
							\verb|/boot|		&	包含\textbf{Linux内核及系统引导程序所需要的文件}，比如 vmlinuz initrd.img 文件都位于这个目录中。			\\
							\verb|/dev|		&	\textbf{设备文件存储目录}，是Linux文件系统的一个闪亮的特性 - 所有对象都是文件或目录。仔细观察这个目录你会发现hda1, hda2等, 它们代表系统主硬盘的不同分区。			\\
							\verb|/etc|		&	存放系统程序或者一般工具的\textbf{配置文件}			\\
							\verb|/lib|		&	库文件存放目录这里包含了\textbf{系统程序所需要的所有共享库文件}，类似于 Windows 的共享库 DLL 文件。			\\
							\verb|/lost+found|	&	在ext2或ext3文件系统中，\textit{当系统意外崩溃或机器意外关机}，而\textbf{产生一些文件碎片放在这里}			\\
							\verb|/mnt|		&	这个目录一般是用于\textbf{存放挂载储存设备的挂载目录}的，比如有cdrom 等目录。有时我们可以把让系统开机自动挂载文件系统，把挂载点放在这里也是可以的。比如光驱可以挂载到/mnt/cdrom 			\\
							\verb|/opt|		&	表示的是可选择的意思，\textbf{有些软件包也会被安装在这里，也就是自定义软件包}\\
							\verb|/proc|		&	/proc目录是伪装的文件系统proc的挂载目录，proc并不是真正的文件系统。这个目录本身是一个“虚拟文件系统（virtual filesystem）”喔！他放置的数据都是在内存当中， 例如系统核心、行程信息（process）、周边设备的状态及网络状态等等。因为这个目录下的数据都是在内存当中， 所以本身不占任何硬盘空间啊！\\
							\verb|/tmp|		&	临时文件目录，有时用户运行程序的时候，会产生临时文件。			\\
							\verb|/usr|		& (Unix Software Resources)	这个是\textbf{系统存放程序的目录}，比如命令、帮助文件等。这个目录下有很多的文件和目录。当我们\textbf{安装一个Linux发行版官方提供的软件包时，大多安装在这里}。			\\
							\verb|/var |		&	这个目录的内容是经常变动的，如/var/log 系统日志存放，分析日志要看这个目录的东西\\
						\hline
				\end{longtable}
			\end{table}
			\paragraph{PATH}
				当执行一个指令(ls)的时候，系统会依照\verb|$PATH|的设置去每个\verb|$PATH|定义的目录下搜寻文件名为(ls)的可执行文件，如果在\verb|$PATH|定义的目录中含有多个文件名为(ls)的可执行文件，那么先搜寻到的同名指令先被执行。
				
				如果命令不在\verb|$PATH|指定路径下时，单纯敲击指令名称是不会执行的，有以下两种方法可以执行该指令
					\begin{enumerate}
						\item 使用绝对路径或相对路径指定命令 \verb|./ls| 或 \verb|/root/ls|
						\item 将目标目录添加到\verb|PATH|中 \verb|PATH = "${PATH}:/root"|
					\end{enumerate}
			
			\paragraph{用户配置}
				\begin{itemize}
					\item  \verb|~/.bash_profile|
					
						每个用户都可\textit{使用该文件输入}\textbf{专用于自己使用的shell}\textit{信息},\underline{当用户登录时},该文件仅仅执行一次!默认情况下,他设置一些环境变量,执行用户的\verb|.bashrc|文件. 此文件类似于\verb|/etc/profile|，也是需要需要重启才会生效，\verb|~/.bash_profile|\textbf{只对当前用户生效}。
					\item  \verb|~/.bashrc|
						
						该文件包含\textbf{专用于你的bash shell的bash信息},\textit{当登录时以及每次\underline{打开新的shell时},该文件被读取}.（每个用户都有一个\verb|.bashrc|文件，在用户目录下） 此文件类似于\verb|/etc/bashrc|，\textbf{不需要重启生效，重新打开一个bash即可生效}， 但\verb|~/.bashrc|只对当前用户新打开的bash生效。
						
					\item  \verb|/etc/profile|
					
						\verb|/etc/profile|对所有用户生效
					
					\item  \verb|/etc/bashrc|
					
						\verb|/etc/bashrc|对所有用户新打开的bash都生效
				\end{itemize}
			
			\paragraph{交换区} 在内存小于2G的情况下，交换分区\textbf{应为内存的2倍}，超过2G的话，交换分区为\textbf{物理内存加上2G}	
			
			\paragraph{符号链接}符号链接又叫软链接,是一类特殊的文件，这个文件包含了\textbf{另一个文件的路径名}
			
			\paragraph{开关机}
				\begin{itemize}[itemindent = 1em]
					\item \verb|shutdown -r 20:30|:在20:30 重启
						\begin{enumerate}
							\item \verb|-c|:取消前一个关机命令
							\item \verb|-h|:关机
							\item \verb|-r|:重启
						\end{enumerate}
					\item \verb|poweroff|
					\item \verb|init 0|
				\end{itemize}
	
	
	\section{导航命令}
		\paragraph{pwd}Print Working Directory 打印当前工作目录，即当前所处位置的绝对路径
		
			\verb|-P|：显示出确实的路径，而非使用链接\verb|link|路径。
			
			\begin{figure}[h]
				\centering
				\includegraphics[scale=0.7]{figure/pwd.png}
				\caption{pwd -P 选项示例}
			\end{figure}
		
		\paragraph{cd}改变当前工作目录
			\begin{itemize}[itemindent = 1em]
				\item 绝对路径： 从根目录 / 开始
				\item 相对路径： 从当前位置开始，. 表示当前目录，.. 表示上级目录
				\item \verb|cd ~| || \verb|cd  |: 进入当前用户家目录
				\item \verb|cd - |: 进入上次目录
				\item \verb|cd .. |: 进入上一级目录
				\item \verb|cd . |: 进入当前目录
			\end{itemize}
			
		\paragraph{ls}列出目录内容
			\begin{itemize}[itemindent = 1em]
				\item 所在路径：\verb|/bin/ls|
				\item 执行权限：所有用户
			\end{itemize}
			\begin{table}[H]
				\centering
				\caption{\textbf{ls }参数说明}
				\begin{longtable}{c|c|m{10cm}}
					\toprule[1.5pt]
					简化选项 & 完整选项 & 意义\\
					\midrule
					\verb|-a|  & \verb|--all| & 列出所有文件，包括以点号开头的文件，这些文件通常是不列出来的(比如隐藏的文件)\\
					\verb|-d|  & \verb|--directory| & 查看目录的详细信息，而不是目录里的内容\\
					\verb|-F|  & \verb|--classify|  & 如果名字是目录，则会加上一个斜杠\\
					\verb|-l|  & 			  & 使用长格式显示结果\\
					\verb|-i|  &			  & \verb|–inode| 印出每个文件的\verb|inode|号\\
					\verb|-r|  & \verb|--reverse|   & 以相反的顺序显示结果\\
					\verb|-S|  & 			  & 按照文件的大小对结果进行排序\\
					\verb|-t|  &			  & 按照文件的修改时间排序\\
					\verb|--color|  	& 	\verb|={never, auto, always}|			  & 结果颜色选项\\
					\verb|--full-time|  &	\verb| |		 						  & 完整呈现结果的最后修改时间 \\
					\bottomrule[1.5pt]
				\end{longtable}
			\end{table}
				
	\section{操作文件和目录}
		\subsection{文件系统}
			\paragraph{EXT2}
				\begin{itemize}
					\item \verb|superBlock|:记录文件系统相关属性
						\begin{itemize}
							\item dataBlock 与 Inode 大小熟悉
							\item dataBlock 与 Inode 数量
						\end{itemize}
					\item \verb|bitMap|:用于判断有哪些数据块可用
					\item \verb|inodeMap|:用于判断有哪些Inode块可用
					\item \verb|inode(s)|:存放文件的相关属性，和相关数据块指针(涉及2级3级指针)。\textit{每个文件仅会占用1个Inode}
					\item \verb|dataBlock(s)|:存放数据的实际地方，\textit{每个数据块只能存放一个文件的内容},所以目录文件一般独自占用一个dataBlock。
				\end{itemize}
				
				\verb|-> 例子：|当我们在 Linux 下的 ext2 \textbf{创建一个一般文件时}， \textbf{ext2 会分配一个 inode 与相对于该文件大小的 block 数量给该文件}。例如：假设我的一个 block 为 4 KBytes ，而我要创建一个 100 KBytes 的文件，那么 linux 将分配一个 inode 与 25 个 block 来储存该文件！ 但同时请注意，由于 inode 仅有 12 个直接指向，因此还要多一个 block 来作为区块号码的记录喔！

			\paragraph{dumpe2fs}列出相关设备的superBlock 的相关信息
				
				\verb|[root@study ~]# dumpe2fs /dev/vda5|
			\paragraph{df}(disk free可用磁盘) 列出文件系统的\textbf{整体磁盘使用量}；
				\begin{itemize}
					\item \verb|-h| 选项， 以人类易读的格式输出（例如，5K，500M 及 5G）
					\item \verb|-a| 选项， 显示所有文件系统的磁盘使用情况
					\item \verb|-i| 选项， 用于显示文件系统的 inode 信息
				\end{itemize}
			
			 参考 \url{https://linux.cn/article-6466-1.html}
			\paragraph{du}du可以\textbf{显示当前目录及子目录的磁盘占用情况}
				\begin{itemize}
					\item \verb|-d|选项可以指明递归目录的深度
					\item \verb|-s|等价于\erhao
					\item \verb|-h|表示以可读的形式显示，比如\verb|B, KB, GB|等
				\end{itemize}
		
		\subsection{相关命令}
		\paragraph{通配符}\verb|->|
			\begin{table}[H]
				\centering
				\caption{通配}
				\begin{tabular}{l|m{14cm}}
					\toprule[1.5pt]
						形式 	   	   & 含义\\
					\hline
						*			 & 匹配任意多字符-包括0个1个\\
						?			& 匹配任一单个字符-不包括0个\\
						\verb|[characters]	|	& 匹配任意一个属于字符集中的字符\\
						\verb|[!characters] |		& 匹配任意一个不属于字符集的字符\\
						\verb|[[:class:]]   |		& 匹配任意一个属于指定类的字符，如\verb|[[:digit:]]|\\
						\verb|[[:alnum:]]	|		& 匹配任意一个字母或数字\\
						\verb|[[:alpha:]]	|		& 匹配任意一个字母\\
						\verb|[[:digit:]]	|		& 匹配任意一个数字\\
						\verb|[[:lower:]]	|		& 匹配任意一个小写字母\\
						\verb|[[:upper:]]	|		& 匹配任意一个大写字母\\
					\bottomrule[1.5pt]
				\end{tabular}
			\end{table}

		\paragraph{cp} 复制文件和目录，默认会改变时间戳
			\begin{itemize}[itemindent = 1em]
				\item \verb|-r|:复制目录
				\item \verb|-p|:连带文件属性复制
				\item \verb|-d|:若源文件是链接文件，则复制链接属性
				\item \verb|-a|:相当于\verb|-pdr|
				\item \verb|-i|:若目标文件已经存在时，在覆盖时会询问动作是否进行。
				\item \verb|-u|:只有目标文件 与 原文件有差异时，才会复制
			\end{itemize}
			
			\verb|cp fileName1  /dir/fileName2|:改名复制
			
			\verb|cp fileName1  /dir/|:原名复制
			
			\verb|->|复制总是希望复制到的数据最后是我们自己的，所以，在默认的条件中，\verb|cp|的\textbf{来源文件}与\textbf{目的文件}的\textbf{权限是不同的}，\textbf{目的文件}的\textbf{拥有者}通常会是\textbf{指令操作者本身}。
			
		\paragraph{mv} 移动或重命名文件和目录
		
			当源文件和目标文件在同一目录就是改名
			
			当源文件和目标文件不在同一目录就是剪切
			
		\paragraph{dd} 用指定大小的块拷贝一个文件，并在拷贝的同时进行指定的转换
			\begin{itemize}[itemindent = 1em]
				\item if=文件名：输入文件名，缺省为标准输入。即指定源文件。\verb|< if=input file >|
				\item of=文件名：输出文件名，缺省为标准输出。即指定目的文件。\verb|< of=output file >|
				\item \url{http://www.cnblogs.com/ginvip/p/6370836.html}
			\end{itemize}
			
		\paragraph{mkdir} 创建目录
			\begin{itemize}[itemindent = 1em]
				\item 可以连续创建多个目录 \verb|mkdir /temp/Japan/cangjing  /temp/Japan/longze ...|
				\item \verb|-m |：设置文件的权限喔！直接设置，不需要看默认权限\verb|umask|的脸色
				\item \verb|-p |: 递归创建 \verb|mkdir -p /Hello/Practice/First|
			\end{itemize}
			
		\paragraph{rmdir} Remove Empty Directory: 即只能删除空目录

		\paragraph{rm} 移除文件和目录，默认删除时会确认
			\begin{itemize}[itemindent = 1em]
				\item \verb|rm -r|:删除目录
				\item \verb|rm -f|:强制删除，不用确认是否删除
			\end{itemize}

		\paragraph{ln} 创建硬链接和符号链接
			\begin{itemize}
				\item \textbf{硬链接}:\verb|ln file file_hard|
					\begin{enumerate}
						\item 拥有相同的i节点  和 存储块，可以看作是带有引用计数的\verb|shared_ptr|，因为本质只有一个资源，而建立新的链接相当于添加新的代理类，但是访问资源都是一个资源。
						\item 可以通过i节点识别:通过命令\verb|ls -i |查看
						\item 不能针对目录使用
					\end{enumerate}
					
				\item \textbf{软链接}:\verb|ln -s file file_soft|在软连接中，文件实际上是一个文本文件，其中包含的有另一文件的位置信息。
					\begin{enumerate}
						\item 类似于windows 的快捷方式
						\item 依赖于硬链接
						\item 有自己的存储块，存储对应的链接命令文件位置。
						\item 访问时，先访问自己的 存储块读取要读写的文件，然后再打开该文件，如果硬链接将该文件删除了，那么执行软链接就会失败。
						\item 改变 软链接文件同样对源文件进行操作。
						\item 删除其对文件是否再存在 没影响
						
						\item \verb|Linux| 使用时尽量\textit{使用}\textbf{绝对路径}，两者都，相对可能会出错
					\end{enumerate}
			\end{itemize}
			
			\verb|->|\textbf{区别}：\url{https://www.ibm.com/developerworks/cn/linux/l-cn-hardandsymb-links/}
			
			我们知道文件都有文件名与数据，这在 \verb|Linux| 上被分成两个部分：\textbf{用户数据} (\verb|user data|) 与\textbf{元数据}(\verb|metadata|)。\verb|用户数据|，即文件数据块 (\verb|data block|)，数据块是记录文件真实内容的地方；而\verb|元数据|则是文件的附加属性，如文件大小、创建时间、所有者等信息。
			
			在 \verb|Linux| 中，\textbf{元数据中的 inode 号}（inode 是文件元数据的一部分但其并不包含文件名，inode 号即索引节点号）\textbf{才是文件的唯一标识而非文件名}。文件名仅是为了方便人们的记忆和使用，系统或程序通过 inode 号寻找正确的文件数据块。图\ref{Link}展示了程序通过文件名获取文件内容的过程。
			
			\begin{figure}
				\centering
				\includegraphics[scale = 1.2]{figure/Link.jpg}	
				\caption{Linux Link Data Access Roud}
				\label{Link}
			\end{figure}
			
			\textbf{查看} \verb|inode| 号可使用命令 \verb|stat 或 ls -i|;
			
			\textbf{查找}\textit{有相同} inode 号的文件 \verb|find / -inum 1114|
			
			\textbf{查看}路径 /home \textit{有相同} inode 的所有硬链接 \verb|find /home -samefile /home/old.file |
			
			\begin{enumerate}
				\item 若一个 \verb|inode |号对应多个文件名，则称这些文件为硬链接。换言之，硬链接就是同一个文件使用了多个别名
				
				\item 软链接与硬链接不同，若文件用户数据块中存放的内容是另一文件的路径名的指向，则该文件就是软连接。软链接就是一个普通文件，只是数据块内容有点特殊。
			\end{enumerate}
			
		
	\section{查看文件}
		\paragraph{cat} 由第一行开始显示文件内容
				\begin{itemize}[itemindent = 1em]
					\item \verb|-b|：列出行号，仅针对非空白行，空白行不标行号。
					\item \verb|-n|：打印出行号，包括空白行
					\item \verb|-v|：列出一些看不出的特殊字符
					\item \verb|-E|：将结尾的断行字符\verb|$|显示出来
					\item \verb|-T|：将\verb|tab |键以\verb|^I|的形式显示出来
					\item \verb|-A|：\verb|-vET| 可以列出特殊字符，而不是以空白代替
				\end{itemize}
		\paragraph{tac} 由最后一行开始显示文件内容， 反向\verb|cat| 输出
			
		\paragraph{nl} 显示的时候，顺道输出行号
		\paragraph{more} 一页一页的显示文件内容
			\begin{itemize}[itemindent = 1em]
				\item \verb|空格 Or f  ->| 翻页
				\item \verb|回车  ->| 换行
				\item \verb|q  ->| 退出
			\end{itemize}
		\paragraph{less} 与\verb|more|类似，但是比\verb|more|更好的是，它\textbf{可以往前翻页}、\textbf{可以查找}
			\begin{itemize}[itemindent = 1em]
				\item \verb|pageUp ->| 向上翻页
				\item \verb|Up  Down ->| 上下换行
				\item \verb|/key ->| 查找， \verb|n 向下查找|
			\end{itemize}
		\paragraph{head} 只看头几行，\verb|head -n 5 ls-text.txt|， 不指定多少行时，默认显式10行。
				
				\verb|-n|：后面接数字，代表显示几行的意思
		\paragraph{tail} 只看尾部几行，\verb|tail -n 5 ls-text.txt|
				\begin{itemize}
					\item \verb|-f| 当文件增长时,输出后续添加的数据
					\item \verb|-s| 与-f合用,表示在每次反复的间隔休眠S秒
				\end{itemize}
			
				为了查看不断更新的日志文件，可以使用的指令\verb|tail -f|
		\paragraph{od} 以二进制的方式读取文件内容
			
		\paragraph{touch} 修改文件时间 或 创建新文件
			
			\subparagraph{文件时间概念}
				\begin{itemize}[itemindent = 1em]
					\item \verb|modification Time(mtime)|：\textbf{当该文件的“内容数据”变更时，就会更新这个时间}！内容数据指的是\textbf{文件的内容}，而不是文件的属性或权限喔！
					\item \verb|status Time(ctime)|：\textbf{当该文件的“状态 （status）”改变时，就会更新这个时间}，举例来说，像是\textbf{权限与属性}被更改了，都会更新这个时间啊。
					\item \verb|access Time(atime)|：当“该文件的内容被取用”时，就会更新这个读取时间 （access）。举例来说，我们使用 \verb|cat| 去读取 \verb|/etc/man_db.conf |， 就会更新该文件的 \verb|atime| 了。
				\end{itemize}
				
			\subparagraph{touch 选项}
				\begin{itemize}[itemindent = 1em]
					\item \verb|-a|: 修改文件访问时间atime
					\item \verb|-c|: 修改文件的时间ctime
					\item \verb|-m|: 修改文件的mtime
				\end{itemize}
	\section{'命令'解释命令}
		\paragraph{type} 说明如何解释命令名：\verb|type  command|
		\paragraph{which} 说明会执行在哪块的可执行程序： \verb|which ls| --> /bin/ls
		\paragraph{man} 显示程序的手册页:\verb|man command|，当有多个级别的命令时，可以使用-f 指定级别。
		\paragraph{--help} 显示程序的使用信息:\verb|command --help|
		\paragraph{apropos} 显示适合的命令:\verb|apropos keyWords|
		\paragraph{whatis} 显示命令的简要描述:\verb|whatis ls|
		\paragraph{info} 显示程序的info 条目:\verb|info command|
		\paragraph{alias} 使用别名创建自己的命令:\verb|alias name='command[s]'|
		\paragraph{参考}\url{http://man.linuxde.net}
		
	\section{重定向}这个功能可以把命令行的输入重定向为从文件中获取内容，也可以把命令行的输出结果重定向到文件中。 使用重定向符‘>’，后接文件名，就可以把标准输出重定向到另一个文件中，而不是显示在屏幕上。
	
		当使用重定向符'\verb|>|' 来重定向标准输出时，目的文件通常会从文件开头部分重新改写。如果需要删除一个文件内容（或者创建一个新的空文件），可以采用这样的方式。\verb|> fileName|
		
		如果不需要从文件的首位置开始覆盖文件，而是从文件的\textbf{尾部开始添加内容}，我们可以使用重定向符‘\verb|>>|’来实现。
		
		可以使用重定向符\verb|&>| 来把标准输出和标准错误都重定向到同一文件中。
		
		\subparagraph{cat}除了查看文件，还可以将不同的文件合并到一个文件里，如 \verb|cat movie*.mpeg >| movie movie.mpeg
		
		\subparagraph{管道}命令从标准输入得到数据，并将数据处理后发送到标准输出。使用管道操作符可以把一个命令的输出 传送到另一个命令的标准输入中。 ‘|’	
		\subparagraph{sort}按照顺序 排列输入表
		\subparagraph{uniq}可以接受来自于标准输入或者一个单个文件名 对应的 已经排好序的数据列表，默认情况下，该命令删除列表中的所有重复行，因此在管道中常与sort 结合使用--> \verb|ls /bin /usr/bin | sort | uniq | less|
		\subparagraph{wc}用来显示文件包含的-行数，字数，字节数\verb|-l, -w, -m, -c|。
		\subparagraph{tee}从stdin 读取数据，并同时输出到stdout 和 文件
		\subparagraph{/dev/null 文件}/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到"\textbf{禁止输出}"的效果。
	\section{shell扩展}
		\subparagraph{echo}把文本参数内容打印到标准输出 :\verb|echo * |--> 打印当前工作目录的所有文件名
		\subparagraph{波浪线扩展}如果没有指定用户名，则扩展为当前用户的主目录： \verb|echo ~ --> /home/me   |  \verb|echo ~foo --> /home/foo|
		\subparagraph{算术扩展}调用方式：\verb|echo $(( expression ))|
		\subparagraph{花括号扩展}\verb|echo F-{A,B,C}-B| --> F-A-B F-B-B F-C-B； \verb|echo n{1..4}| --> n1 n2 n3; 	\verb|echo n{z..a}| --> nz ny nx . na;
		\subparagraph{命令  替换}可以把一个命令的输出作为一个扩展模式使用：\verb|echo $(ls)| -->Desktop Documnet Music Pictures.. ,即在需要命令参数处调用\verb|‘$(Command)’|
		\subparagraph{双引号扩展}如果把文本放到双引号里，那么所有特殊字符都将失去特殊含义除算数扩展和命令替换
		\subparagraph{单引号扩展}如果把文本放到单引号里，那么所有特殊字符都将失去特殊含义，没有除
	\section{权限}
		\subsection{基础}
		\begin{figure}[h]
			\centering
			\includegraphics[scale = 1]{figure/fileDescription.png}
			\caption{ls -l 文件权限}
		\end{figure}
		
		\begin{lstlisting}
	Type Owner Group Others
	[-    rwx   rwx   ---]
	[-    111   111   000]
	[-    421   421   000]
	[-     7     7     0 ]
		\end{lstlisting}
		 \subparagraph{chmod}更改文件的模式
		 
			 chmod 命令符号表示如下：
				\begin{table}[H]
					\centering
					\caption{chmod 作用对象表示法}
					\begin{tabular}{l|m{14cm}}
						\hline
						符号 	   	   & 含义\\
						\hline
						\verb|u |		& user 缩写，表示文件或者目录的所有者\\
						\verb|g	|		& 文件所属群组\\
						\verb|o	|		& others 的缩写，表示其他用户\\
						\verb|a	|		& all 的缩写，是u g o 三者的组合\\
						\verb|+ |		& 添加权利\\
						\verb|-	|		& 删除权利\\
						\hline
					\end{tabular}
				\end{table}	
			
			如下示例：	
			\begin{lstlisting}[frame=L,xleftmargin=.1\textwidth]
	$chmod u+x test.txt
	--> 给test.txt 的user 添加可执行的权限
			\end{lstlisting}
			
			各种权限可以使用数字来表示，设置权限时可以直接使用数字进行设置:
			
			\verb|chmod Owner+Group+Others file--> chmod 771 file|	 
		 \subparagraph{umask}设置文件的默认权限,该值是需要减去的权限. 将给出的掩码与原文件的权限进行\textbf{异或运算}，即\textbf{如果掩码为1，那么将该位置的权限擦除}
			 \begin{lstlisting}[frame=L,xleftmargin=.1\textwidth]
	$umask 0002
	--> 设置默认权限 0 000 000 010 ：即如果其他用户拥有写权限的话，将擦除该权限
			 \end{lstlisting}
			 
			 如果umask 为022，所以user的权限并没有被拿掉什么权限，但是group 和 others 的权限都被拿掉了2，也就是写(w)权限。
			 \begin{lstlisting}[frame=L,xleftmargin=.1\textwidth]
	$umask 022
	 --> 创建文件时：（-rw-rw-rw-） - （-----w--w-） ==> -rw-r--r--
	 --> 创建目录时：（drwxrwxrwx） - （d----w--w-） ==> drwxr-xr-x
			 \end{lstlisting}
		 \subparagraph{chown}更改文件所有者, 所有者必须是已经存在系统中的帐号，也就是在\verb|/etc/passwd |这个文件中有纪录的使用者名称才能改变。
		 \subparagraph{chgrp}更改文件所属群组,不过，请记得，要被改变的群组名称必须要在\verb|/etc/group|文件内存在才行，否则就会显示错误！
		 \subparagraph{passwd}更改用户密码
		 
		 \subparagraph{Set UID}
			 普通用户 执行 特定用户的命令时， 短暂时间内 转化为 特定用户，从而拥有一些只有特定用户拥有的权限，从而使用一些特定用户可以的动作。
			 
			 只针对可执行权限x. \verb|x->s|,即只有文件的owner位的权限如下形式才可以完成此操作。
			 
			 \verb|-rws r-x r-x|
			 
			 \textbf{添加该权限}：\verb|chmod u=rwxs file| 或 \verb|chmod u+s file|
			 
			 参考\verb|->|鸟哥私房菜6.4.3
			 
		 \subsection{UID EUID}
			 \url{http://keren.blog.51cto.com/720558/144908}
	\section{进程}
		\paragraph{ps}\textbf{显示当前}所有进程的运行情况
			
			将程序\textit{运行至后台}..\verb|xxCommand &|
			
				\begin{table}[H]
					\centering
					\caption{ps 参数含义}
					\begin{tabular}{l|m{14cm}}
						\hline
						符号 	   	   & 含义\\
						\hline
						\verb|l |		&  长格式输出\\
						\verb|u	|		&  按用户名和启动时间的顺序来显示进程\\
						\verb|j	|		&  用任务格式来显示进程\\
						\verb|f	|		&  用树形格式来显示进程\\
						\verb|a |		&  显示所有用户的所有进程(包括其它用户)如：\verb|ps a| \textit{显示现行终端机下的所有程序}\\
						\verb|x	|		&  显示无控制终端的进程\\
						\verb|r	|		&  显示运行中的进程\\
						\hline
					\end{tabular}
				\end{table}	
				参考：\url{http://www.cnblogs.com/wangkangluo1/archive/2011/09/23/2185938.html}
		\paragraph{后台执行}
				\verb|Command &|
				
				\textbf{特点:}是执行后\textbf{命令行不会一直占用}，可以执行其他命令.例如
				\begin{lstlisting}
	$firefox &
	...
	
	$Available..
				\end{lstlisting}
		\paragraph{其他}
			\subparagraph{ctrl+z} 暂停当前运行进程
			\subparagraph{ctrl+c} 结束当前运行进程
			
			\subparagraph{top}\textbf{实时动态显示}当前所有任务的资源占用情况
			\subparagraph{jobs}列出所有活动作业的状态信息
			
			\subparagraph{bg}设置在后台中运行作业
			\subparagraph{fg}设置在前台中运行作业
			\subparagraph{kill}发送信号给某个进程，对应的c函数也叫kill();
			\subparagraph{killall}杀死指定名字的进程
		
	\section{环境/etc}
		\subsection{基本概念}
			login \textbf{shell}[需要输入用户名和密码的] 启动时会读取一个或多个启动文件以配置系统环境：
				\begin{itemize}[itemindent = 1em]
					\item \verb|/etc/profile| 适用于所有用户的全局配置脚本
					\item \verb|~/.bash_profile| 用户个人启动文件，可扩展或重写
					\item \verb|~/.profile|
				\end{itemize}
				
			non-login \textbf{shell} 则会读取以下文件
				\begin{itemize}[itemindent = 1em]
					\item \verb|/etc/bash.bashrc| 适用于所有用户的全局配置脚本
					\item \verb|~/.bashrc| 用户个人启动文件，可扩展或重写
				\end{itemize}
		
		\subsection{相关命令}
		\subparagraph{printenv}打印部分或全部的环境信息
			\begin{table}[H]
				\centering
				\caption{一些必要的环境变量}
				\begin{tabular}{l|m{14cm}}
					\hline
					符号 	   	   & 含义\\
					\hline
					\verb|DISPLAY|		&  运行图形界面环境时界面的名称\\
					\verb|EDITOR|		&  用于文本编辑的程序名称\\
					\verb|SHELL|		&  本机shell 名称\\
					\verb|HOME|		&  本机主目录的路径名\\
					\verb|PWD|		&  当前工作目录\\
					\verb|USER|		&  用户名\\
					\verb|PATH|		&  以冒号分割的一个目录列表，\textbf{当用户输入一个可执行程序的名称时，会查找该目录列表}\\
					\hline
				\end{tabular}
			\end{table}	
			
			\verb|PATH 变量| 通常时由启动文件 \verb|/etc/profile| 中的一段代码设定，但并不如此，取决于系统的发行版本
			\begin{lstlisting}
// 这段代码将$HOME/bin  添加到PATH值的尾部
	PATH = $PATH:$HOME/bin
			\end{lstlisting}
			
			还有一个常见的命令 \verb|export|, 该命令会告诉shell, 将shell的子进程使用\verb|PATH|变量的内容
			\begin{lstlisting}
	export PATH
			\end{lstlisting}
			
			修改环境变量时应当把修改放入以下文件
			\begin{itemize}[itemindent = 1em]
				\item \verb|.bash_profile 或者 其他等效文件(如 Ubuntu中的 .profile)|
			\end{itemize}
			
			其他的改变则应录入\verb|.bashrc|,如
			\begin{lstlisting}
//  .bashrc 文件增加如下代码
	umask 0002
	export HISTSIZE = 1000
	alias ll = 'ls -l --color=auto'
			\end{lstlisting}
			
			但是只要启动shell时才会读取\verb|.bashrc|, 所以对\verb|.bashrc| 做出的修改只有在关闭shell终端回话并重启的时候才会生效。当然我们也可以使用以下命令强制命令bash 重新读取\verb|.bashrc| 文件
			
			\begin{lstlisting}
	$source .bashrc
			\end{lstlisting}
		\subparagraph{set}设置shell 选项
		\subparagraph{export}将环境导出到随后要运行的程序中
		\subparagraph{alias}为命令创建一个别名.
		
	\section{VI 编辑器}
		\subsection{基本模式}
			\begin{itemize}
				\item 普通模式
				\item 插入模式
				\item 可视模式
				\item 选择模式
				\item 命令行模式
				\item ex模式
			\end{itemize}
			\begin{figure}[h]
				\centering
				\includegraphics[scale = 0.5]{figure/viInsert.png}
				\caption{vi插入示例}
			\end{figure}

		\subsection{模式转换}
			模式如下，所有在\textbf{使用命令的时候一般需要按Esc按键返回到命令模式下才可以.}.而并非在插入模式与ex转义方式下。
			通过输入vi的插入命令（i）、附加命令（a）、打开命令（o）、替换命令（s）、修改命令(c）或取代命令（r）可以从命令方式进入输入方式。
			\begin{figure}[h]
				\centering
				\includegraphics[scale = 0.5]{figure/vi.png}
				\caption{vi模式转换示例}
			\end{figure}
		
		\subsection{常用命令}
			\url{http://blog.csdn.net/weixin_40910753/article/details/79077074}
			
			$$\verb|数字奥义(单，范围)| + \verb|命令| + \verb|正则光标|$$
			
			\subsubsection{选中一块区域并缩进缩出}
				\subparagraph{可视模式}
					按\verb|ESC| 进入正常模式
					\begin{enumerate}
						\item 按\verb|v|进入视觉模式
						\item 按\verb|shift|，移动上下键选择文本
						\item \verb|>| 缩进，\verb|<| 缩出
					\end{enumerate}
					
				\subparagraph{正常模式}
					按\verb|ESC| 进入正常模式
					
					\verb|数字的奥义| + \verb@>>|<<@
					
			\subsubsection{移动光标}
				按\verb|ESC| 进入正常模式
				\subparagraph{数字0} 移动光标至本行开头，\verb|Home| 也有此功能
				\subparagraph{\$} 移动光标至本行末尾，\verb|End| 也有此功能
				\subparagraph{gg} 移动光标到文件第一行
				\subparagraph{G} 移动光标到文件最后一行
				\subparagraph{b} 移动光标到该单词的第一个字母
				\subparagraph{e} 移动光标到该单词的最后一个字母
				\subparagraph{w} 移动光标到下一个单词的起始处
				\subparagraph{num+G} 移动光标到第 \verb|num| 行
				
			\subsubsection{删除操作}
				按\verb|ESC| 进入正常模式
				\subparagraph{x} 删除当前字符
				\subparagraph{d0}删除当前光标到行开头字符
				\subparagraph{d\$}删除当前光标到结尾字符
				\subparagraph{dW} 删除整个单词
				\subparagraph{dd} 删除当前行
				\subparagraph{d+G} 删除当前行到文件末尾
				\subparagraph{num+dd} 删除与本行在内的往后 \verb|num| 行
				
					\verb|数字 + motion = | 重复多个motion
				\subparagraph{d+num+G} 删除当前行到第\verb|num|行
			
			\subsubsection{撤销恢复}	
				\subparagraph{u} undo  操作
				\subparagraph{ctrl+r} redo 操作
			
			\subsubsection{复制粘贴}
				按\verb|ESC| 进入正常模式
				\subparagraph{y0}复制当前光标到行开头字符
				\subparagraph{y\$}复制当前光标到结尾字符
				\subparagraph{yW} 复制整个单词
				\subparagraph{yy} 复制当前行
				\subparagraph{num+yy} 复制连同当前行往后的num行
				\subparagraph{y+num+G} 复制当前行到文件第num行
				\subparagraph{y+G} 复制当前行到文件末尾
				\subparagraph{p} 粘贴复制文本到当前光标\textbf{前}
				\subparagraph{P} 粘贴复制文本到当前光标\textbf{后}
				\subparagraph{J} 合并后一行至当前行
				\url{https://stackoverflow.com/questions/2770739/vim-error-e492-not-an-editor-command-dd}
				
/			\subsubsection{查找}
				按\verb|ESC| 进入正常模式
				\subparagraph{'/keyword'} 在当前文本 向后查找 \verb|keyword|
				\subparagraph{'?keyword'} 在当前文本 向前查找 \verb|keyword|
				\subparagraph{n} 寻找下一个 
				\subparagraph{N} 寻找上一个 
				\subparagraph{\%} 快速\textbf{匹配括号}
				
			\subsubsection{全局搜索和替换}
				\verb|esc : 进入ex 模式|
				\begin{table}[H]
					\centering
					\caption{ex 搜索替换使用规范}
					\begin{tabular}{l|m{13cm}}
						\hline
						符号 	   	   & 含义\\
						\hline
						\verb|：|	&  分号用于启动一条ex 命令\\
						\verb|% |	 &  确定作用范围，\verb|%|代表从文件的第一行到最后一行，\verb|1,5| 代表第一行到第5行，\verb|2,$| 代表从第二行到最后一行. 如果不指定范围的话，只会在当前行生效\\
						\verb|s |	 &  指定了具体的操作- 本次操作为替换操作(搜索和替换)\\
						\verb|s/find/replace|		&  搜说find关机字，并将其替换为replace\\
						\verb|g |	 &  替换正行\\
						\verb|c |	 &  确认是否替换\\
						\hline
					\end{tabular}
				\end{table}	
				
				\verb|:%s/find/replace/g| 全文将find 替换为 replace
				
				\verb|:1,4s/find/replace/gc| 将第一行到第4行的find 全部替换为 replace,并询问确认意见
				
				\url{http://blog.sina.com.cn/s/blog_736f1c59010136ry.html}
			\subsubsection{查找删除注释}
				\subparagraph{'s/old/new/ '}用old替换new，替换当前行的第一个匹配
				\subparagraph{'s/old/new/g '}用old替换new，替换当前行的所有匹配
				\subparagraph{'\%s/old/new/'}用old替换new，替换所有行的第一个匹配
				\subparagraph{'\%s/old/new/g'}用old替换new，替换整个文件的所有匹配
				\subparagraph{',5 s/\^ /\#/g'} 注释当前行到第5行
				\subparagraph{',+5 s/\^ /\#/g'} 注释当前行与之后的5行
				\subparagraph{'3,5 s/\^ \#//g'} 解除3-5行的注释	
			
			\subsubsection{查看目录下有什么文件}
				\verb|:! command|
				
				
				\verb|:! ls /| 列出根目录文件			
			\subsubsection{文件保存}
				\verb|esc : 进入ex 模式|
				\subparagraph{:w} \verb|:w newFileName| 另存为newFileName
				\subparagraph{局部另存为}
					\begin{itemize}
						\item \verb|esc  v|进程可视模式
						\item \verb|shift |选中文本
						\item \verb|: w newFileName| 将选中的另存为newFileName
					\end{itemize}			
				
				\subparagraph{文件覆盖}
					\verb|:w! oldFile| 将oldfile 用现有内容覆盖
						
						
				\subparagraph{文件合并}
					\verb|:r file| 将file文件的内容 合并到当前文件 光标的下方。
					
			\subsubsection{编辑多文本}
				\url{https://www.cnblogs.com/end/archive/2012/06/12/2546757.html}
				\subparagraph{vi file1 file2 }
					\begin{itemize}[itemindent = 2em]
						\item \verb|-o| 垂直并排
						\item \verb|-O| 水平并排
						\item \verb|ctrl + w + w| 切换到下一个文件
						\item \verb|ctrl + w + 方向键| 切换到相对位置的文件
						\item \verb|a| 作用于所有，在ex模式下使用\verb|:wa :qa|
					\end{itemize}
				
				\subparagraph{在不同窗口中打开多个文件}	
					如果\textbf{已经打开}一个了一个文件，
					
					\begin{itemize}[itemindent = 2em]
						\item \verb|esc ：|进入命令模式
						\item \verb|:sp newFile|水平分割继续打开第二个文件
						\item \verb|:vsp newFile|纵向分割打开第二个文件
					\end{itemize}
				
					或者用 \verb|vi -o file1 file2 file3....|用\textbf{分割屏幕窗口方式同时打开多个文件}。
					
				\subparagraph{分屏操作}
					\begin{itemize}[itemindent = 2em]
						\item \verb|ctrl+w s|   对当前文档内容分屏显示
						\item \verb|ctrl+w q|   关闭所处分屏
						\item \verb|ctrl+w o |  仅显示当前分屏内容
					\end{itemize}
				
				\subparagraph{n 与 N} 切换下一个文件
				\subparagraph{:buffers} 显示当前打开的文件们
				\subparagraph{:buffer num} 切换到文件num
				
				\subparagraph{:e newfile}[*常用] 载入更多的文件，然后使用\verb|ctrl + ^|在文件之间切换
				
					\begin{itemize}[itemindent = 2em]
						\item \verb|:ls|  展示全部的打开文档
						
						\item \verb|:xn|  切换到向下的第x个文档
						
						\item \verb|n ctrl+6 |切换到第n个buffer
						
						\item \verb|ctrl+6  或 :e#|   回到前一个编辑文件
					\end{itemize}
				
				
				
				
				\subparagraph{:tabe}
				\url{http://blog.csdn.net/achang21/article/details/44562253}
				\subparagraph{文件间复制} 跟普通复制粘贴一样，只是需要切换目标文件先
				
				\subparagraph{插入整个文件} \verb|:r insertFile| 将insertFile 的内容插入到光标位置之前 	
		
		\subsection{配置}
			\url{https://segmentfault.com/a/1190000011466454}
			
			\subsubsection{.vimrc}
				\verb|.vimrc| 是 \verb|Vim| 的配置文件，需要我们自己创建
				\begin{lstlisting}
	cd Home               // 进入 Home 目录
	touch .vimrc          // 配置文件
	
	# 安装插件管理工具 vim-plug
	# Unix
	# Vim
	curl -fLo ~/.vim/autoload/plug.vim --create-dirs \
	https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
	# Neovim
	curl -fLo ~/.local/share/nvim/site/autoload/plug.vim --create-dirs \
	https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim
				\end{lstlisting}
			
			\subsubsection{基本配置}
				\begin{itemize}
					\item 文件编码 \verb|set encoding=utf-8|
					\item 显示行号 \verb|set number|
					\item 显示光标当前位置 \verb|set ruler|
					\item 设置缩进 
					    \begin{lstlisting}
	set cindent	
	set tabstop=2
	set shiftwidth=2
					    \end{lstlisting}
				    
					\item  突出显示当前行 \verb|set cursorline|
				\end{itemize}
				
			\subsubsection{插件配置}
				\subparagraph{树形目录}Plug 'scrooloose/nerdtree'
				\subparagraph{代码补全}Plug 'Valloric/YouCompleteMe'
				\subparagraph{git显示}Plug 'airblade/vim-gitgutter'
							
		\subsection{常用插件}
			\subsection{vundle 插件管理器}
				\url{http://blog.csdn.net/myloveqingmu/article/details/52518563}
			
			
			\url{http://blog.csdn.net/mergerly/article/details/51671890}
			
			\url{http://blog.csdn.net/jack__cj/article/details/52671312}
			\subsubsection{ctags}
				安装：\url{http://blog.csdn.net/u013445530/article/details/46726109}
				
				tags下载：\url{https://wiki.geany.org/tags/start}
				\begin{enumerate}
					\item 安装软件：\verb|sudo apt-get install ctags|
					\item 下载补全资源：\verb|.h|
					\item 生成tags文件：ctag 生成 \verb|tags|文件
					\item 使用：\verb|ctrl+p| 与 \verb|ctrl+n| 使用
				\end{enumerate}
				
			\subsubsection{YouCompleteMe}
				
	\section{存储介质挂载}
		\subsection{挂载点的意义}
			每个 \verb|filesystem| 都有独立的 \verb|inode、 block 、superblock| 等信息，\textbf{这个文件系统}\textit{要能够}\textbf{链接到目录树}\underline{才能}\textbf{被我们使用}。 \textbf{将文件系统与目录树结合的动作我们称为“ 挂载 ”}。 
			
			重点是： \textbf{挂载点一定是目录}，\textit{该目录为进入该文件系统的入口}。 因此并不是你有任何文件系统都能使用，必须要“挂载”到目录树的某个目录后，才能够使用该文件系统的。
			
		\subsection{挂载}
			\begin{itemize}
				\item windows \verb|->| 硬件设备映射为一个盘符
				\item linux \verb| ->| 将硬件设备挂载成(映射到)一个目录
			\end{itemize}

			linux 的每个挂载了分区的目录 就相当于 windows系统中的盘符，比如/home/ftp 和 /oracle目录我们就可以把她看做一个盘符和一个分区关联
			
			\url{http://blog.csdn.net/gongweijiao/article/details/8425629}
		\subparagraph{mount}查询系统中已经挂载的设备
		
			\verb|mount [-t 文件系统] [-o 特殊选项]  设备文件名  挂载目录|
			
			\begin{itemize}
				\item \verb|-a| 依据配置文件\verb|/etc/fstab|的内容，开机自动挂载
				\item \verb|-t| 文件系统类型可以有 ext3, ext4, fat16, fat32等
				\item \verb|-o| 可以指定挂载的额外选项
			\end{itemize}
		
			\verb|-> 挂载U盘|:此盘在windows下格式化为fat32文件系统
				\begin{enumerate}
					\item 挂u盘之前，运行命令\verb|cat /proc/partitions|,\textbf{看看现在系统中有哪些分区}。插上u盘以后，再次运行上述命令，看看多出来什么分区（通常是sda1或者 sdb1)
					
					\item 输入 \verb|fdisk -l /dev/sda| 查看输出结果,\textbf{决定以什么文件系统挂载}。
					\begin{lstlisting}[frame=L,xleftmargin=.1\textwidth]
	#fdisk -l /dev/sda 
	 Disk /dev/sda: 131 MB, 131104768 bytes      
	 3 heads, 32 sectors/track, 2667 cylinders      
	 Units = cylinders of 96 * 512 = 49152 bytes 
	 Device Boot      Start         End      Blocks   Id System     
	/dev/sdb1   *           1        2668      128016    6 FAT16
					\end{lstlisting}
					
					\item 根据文件系统类型挂载，如\verb|mount -t msdos /dev/sdb1 /mnt/usb|
					
					可以使用\verb|cat /proc/filesystems |查看当前系统支持的文件系统格式
						\begin{itemize}
							\item 如果是\verb|fat16|格式，就用命令：  \verb|mount -t msdos /dev/sdb1 /mnt/usb| 
							\item 如果是\verb|fat32|格式，就用命令： 	\verb|mount -t vfat /dev/sdb1 /mnt/usb -o iocharset=utf8 |
							\item 如果是\verb|ext2| 格式，就用命令：  \verb|mount -t ext2 /dev/sda1 /mnt/usb|
							\item 如果是\verb|NTFS| 格式，就用命令：  \verb|mount -t ntfs /dev/sda1 /mnt/usb|
						\end{itemize}
				\end{enumerate}
				
				挂载实例：\url{https://wenku.baidu.com/view/ef8aa226dd36a32d73758139.html}
	\section{网络}	
			\subparagraph{ping} \textbf{向网络主机发送特殊数据包}(\verb|ICMP ECHO_REQUEST|). 多数网络设备收到该数据包后会做出回应，通过此法可判断网络链接(两者间)是否正常. \verb|ping  baidu.com|
			
			\subparagraph{traceroute} \textbf{跟踪网络数据包的传输路径}，会显示文件通过网络从本地系统到指定主机过程中所有停靠点的列表。 \verb|traceroute  slashdot.org|
			
			\subparagraph{netstat} 检查网络设置以及相关统计数据，\verb|-ie|可以检查系统的网络接口信息，\verb|-r| 可以显示内核的网络路由表
				\url{http://www.cnblogs.com/ggjucheng/archive/2012/01/08/2316661.html}
				
				\begin{table}[H]
					\centering
					\begin{tabular}{l|m{12cm}}
						\hline
						\verb|netstat |   	   & \verb|options| \\
						\hline
						\verb| |   	   & \verb|-a |(\verb|all|)显示所有选项，默认不显示\verb|LISTEN|相关 \\
						\verb| |   	   & \verb|-t |(\verb|tcp|)仅显示\verb|tcp|相关选项\\
						\verb| |   	   & \verb|-u |(\verb|udp|)仅显示\verb|udp|相关选项 \\
						\verb| |   	   & \verb|-n |拒绝显示别名，能显示数字的全部转化成数字 \\
						\verb|netstat |   	   & \verb|-l |仅列出有在 \verb|Listen| (监听) 的服務状态\\
						\verb| |   	   & \verb|-p |显示建立相关链接的程序名 \\
						\verb| |   	   & \verb|-r |显示路由信息，路由表 \\
						\verb| |   	   & \verb|-e |显示扩展信息，例如\verb|uid|等\\
						\verb| |   	   & \verb|-s |按各个协议进行统计 \\
						\verb| |   	   & \verb|-c |每隔一个固定时间，执行该\verb|netstat|命令\\
						\hline
					\end{tabular}
				\end{table}	
					
				\verb|LISTEN和LISTENING|的状态只有用\verb|-a|或者\verb|-l|才能看到
				
				\begin{itemize}[itemindent = 1em]
					\item 列出所有 \verb|tcp| 端口: \verb|netstat -at|
					\item 列出所有 \verb|udp| 端口: \verb|netstat -au|
					\item 只列出所有处于监听状态 \verb|tcp| 端口： \verb|netstat -lt|
					\item 显示\verb|tcp|和进程名称 \verb|netstat -pt|
				\end{itemize}
				
			\subparagraph{ftp:lftp:sftp} \verb|File Transfer Protocol|,ftp 服务器 就是那些包含供 网络上传、下载文件的机器
				\begin{table}[H]
					\centering
					\caption{FTP 使用说明}
					\begin{tabular}{l|m{13cm}}
						\hline
						命令 	   	   & 含义\\
						\hline
						\verb|ftp server|	&  建立 FTP 连接，在命令上中先输入\verb|ftp|然后空格跟上 \verb|FTP 服务器的域名 'domain.com'| 或者 \verb|IP 地址|\\
						\verb|anonymous|	 &  使用用户名密码登录,绝大多数的 \textbf{FTP 服务器是使用密码保护的}，因此这些 FTP 服务器会询问\verb|'username'|和\verb|'password'|.	如果你连接到被称作匿名 FTP 服务器，可以尝试\verb|anonymous|作为用户名以及使用空密码：\verb|Name: anonymous, Password:|\\
						\verb|目录操作|	 &  FTP 命令可以列出、移动和创建文件夹，如同我们在本地使用我们的电脑一样。\verb|ls|可以打印目录列表，\verb|cd|可以改变目录，\verb|mkdir|可以创建文件夹\\
						\verb|使用 FTP 下载文件|		&  在下载一个文件之前，我们首先需要使用\verb|lcd|命令\textbf{设定本地接受目录位置}。
						\verb|lcd /home/user/yourdirectoryname| 如果你不指定下载目录，文件将会下载到你登录 FTP 时候的工作目录。现在，我们可以使用命令 \verb|get| \textbf{来下载文件}，比如：\verb|get file|\textbf{文件会保存在}使用\verb|lcd|命令设置的目录位置\\
						\verb|使用 FTP 上传文件|	 &  使用 \verb|put|命令上传文件：\verb|put file|\\
						\verb|关闭 FTP 链接| &  \verb|quit exit bye|3 个命令都可以\\
						\hline
					\end{tabular}
				\end{table}	
				
			\subparagraph{wget} 非交互式网络下载工具 \verb|wget http://www.linuxde.net/testfile.zip|
			
			\subparagraph{*远程操作 ssh} 安全登录远程计算机:SSH 解决了与远程主机进行安全通信的两个基本问题：1、该协议可以验证远程主机的身份是否真实;2、该协议将本机与远程主机之间的通信内容全部加密
				
				SSH协议 包括2部分：1、运行在远程主机上的SSH服务端，用来监听端口\textbf{22} 上可能过来的连接请求;2、是本地系统上的SSH客户端，用来与远程服务器进行通信
				
			关于SSH 的相关命令有 \verb|scp|，\verb|sftp|,分别表示远程拷贝 和 更简单高效快速的ftp
			
			例如：执行\verb|ssh happycast.net|命令，然后输入密码，接着就可以直接访问该服务器..但是每次连接都得输入密码我们可以使用以下步骤进行简化：
				\begin{lstlisting}
	$ssh-keygen
	$cd ~/.ssh
	$ls
	id_rsa  id_rsa.pub
	
	// 然后我们把公钥id_rsa.pub 上传至服务器/home/Usr1/.ssh/authorized_keys即可
	$ssh-copy-id 服务器名(Usrl@happycasts.net)
				\end{lstlisting}
			
			\subparagraph{*数据传输 rsync}见归档备份
			
			\subparagraph{nc}\verb|netcat|所做的就是在两台电脑之间建立链接并返回两个数据流，在这之后所能做的事就看你的想像力了。你能建立一个服务器，传输文件，与朋友聊天，传输流媒体或者用它作为其它协议的独立客户端。
				
				\url{http://blog.csdn.net/zhangxiao93/article/details/52705642}
				\begin{itemize}[itemindent = 1em]
					\item 端口扫描
					\item ChatServer
					\item 文件传输
				\end{itemize}
				
			\subparagraph{pv}是 \verb|Pipe Viewer| 的简称，意思是通过管道显示数据处理进度的信息。这些信息包括已经耗费的时间，完成的百分比（通过进度条显示），\textit{当前的速度，全部传输的数据，以及估计剩余的时间}。
			
				\url{http://www.jb51.net/LINUXjishu/409870.html}
				
			\subparagraph{tcpdump}
				
				\url{http://www.cnblogs.com/ggjucheng/archive/2012/01/14/2322659.html}
				\begin{itemize}[itemindent = 1em]
					\item 监视指定主机的数据包
						\begin{itemize}
							\item 打印所有\textbf{进入或离开}\verb|sundown|的数据包:
							
								\verb|tcpdump host sundown| 或 \verb|tcpdump host 210.27.48.1 |
							\item 打印helios \textbf{与} hot \textbf{或者与} ace 之间通信的数据包
							
								\verb|tcpdump host helios and \( hot or ace \)| 或 
								
							    \verb|tcpdump host 210.27.48.1 and \ (210.27.48.2 or 210.27.48.3 \)| 
							\item  打印ace \textbf{与} 任何不是\verb|helios|主机 通信的IP 数据包
							
								\verb|tcpdump ip host ace and not helios| 或 
								
								\verb|tcpdump ip host 210.27.48.1 and ! 210.27.48.2|
							\item 截获主机\verb|hostname|\textbf{发送的}所有数据
							
								\verb|tcpdump -i eth0 src host hostname|
							\item 监视所有\textbf{送到}主机\verb|hostname|的数据包
							
								\verb|tcpdump -i eth0 dst host hostname|
						\end{itemize}
						
					\item 获取主机\verb|10.2.4.1|在端口23上\textbf{接收或发出}的包：
							\verb|tcpdump tcp port 23 and host 10.2.4.1|
					
					\item  () 得使用转义字符进行，要么不识别
					
						\verb|tcpdump \(src 172.17.14.98 and dst 172.17.15.112\) or \(src 172.17.15.112 and dst 172.17.14.98\)|
				\end{itemize}
				
			\subparagraph{iperf}可以测试\verb|TCP和UDP|带宽质量。\verb|iperf|可以报告带宽，延迟抖动和数据包丢失。
			
			\subparagraph{ifconfig}
			
			\subparagraph{iptables}
			
			\subparagraph{vmstate} vmstat命令是最常见的\textbf{Linux/Unix监控工具}，可以展现\textbf{给定时间间隔}的\textbf{服务器的状态值},包括服务器的\textbf{CPU使用率，内存使用，虚拟内存交换情况,IO读写情况}
			
			\verb|-> 使用：|
			
			\verb|vmstat [-a] [-n] [-S unit] [delay [ count]]|
			
			\verb|vmstat [-s] [-n] [-S unit]|
			
			\verb|vmstat [-m] [-n] [delay [ count]]|
			
			\verb|vmstat [-d] [-n] [delay [ count]]|
			
			\verb|vmstat [-p disk partition] [-n] [delay [ count]]|
			
			\verb|vmstat [-f]|
			
			
			\begin{table}[H]
				\centering
				\begin{tabular}{l|m{14cm}}
					\hline
					\verb|参数 |   	   & \verb|含义| \\
					\hline
					\verb|delay |      & 刷新时间间隔。如果不指定，只显示一条结果。	\\
					\verb|count |      & 刷新次数。如果不指定刷新次数，但指定了刷新时间间隔，这时刷新次数为无穷。	\\
					\verb|-a |   	   & 开启显示active/inactive memory	\\
					\verb|-f |   	   & 显示此系统启动以来的forks的总数，包括fork、vfork和clone system calls	\\
					\verb|-m |   	   & 显示slabinfo信息	\\
					\verb|-n |   	   & 只显示头信息，不周期性显示.也就是说开启这个参数，只显示头部信息一次。	\\
					\verb|-s |   	   & 显示各种事件计数器表和内存统计信息，这显示不重复	\\
					\verb|-d |   	   & 显示磁盘统计数据	\\
					\verb|-w |   	   & 可以扩大字段长度，当内存较大时，默认长度不够完全展示内存。	\\
					\verb|-p |   	   & 显示磁盘分区数据	\\
					\verb|-S |   	   & 参数S控制输出性能指标的单位，k(1000) K(1024) 或 M(1048576) 默认单位为K（1024 bytes）	\\
					\hline
				\end{tabular}
			\end{table}	
			
		 \url{http://www.cnblogs.com/tommyli/p/3746187.html}
		 
		 \url{http://www.cnblogs.com/ggjucheng/archive/2012/01/05/2312625.html}
	\section{正则表达式}
		$$\verb|正则表达式|=
			\begin{cases}
				\verb|字符类|\\
				\verb|数量限定类|\\
				\verb|位置限定类|
			\end{cases}$$	
		
		\url{http://www.cnblogs.com/hanxiaoyu/p/5759477.html}

		\subsection{字符类}
			\begin{table}[H]
				\centering
				\begin{tabular}{l|m{7cm}|m{8cm}}
					\hline
					\verb|字符 |   	   & \verb|含义| & \verb|例子|\\
					\hline
					\verb|. |   	   & 匹配任意一个字符 & \verb|abc. |可以匹配 \verb|abcd、 abc9| 		\\
					\verb|[]|   	   & 匹配括号中的任意一个字符 & \verb|[abc]d |可以匹配 \verb|ad、 bd、cd|		\\
					\verb|- |   	   & 在\verb|[]|中使用，表示字符范围 &\verb|[0-9 a-f A-F] |可以匹配一位16进制数字	\\
					\verb|^ |   	   & 位于括号内的开头，匹配括号中的字符外的任意一个字符 &\verb|[^xy]  |可以匹配 除\verb|x、y|之外的任一字符		\\
					\verb|[[:xx:]]|	   & 预定义的一些命名字符 & \verb|[[:digit:]] |匹配一个数字    \\
					\hline
				\end{tabular}
			\end{table}	
		
			\verb|[\d]| 等价于 \verb|[0-9]|
			
			\verb|/ |只是在某些语言中作为正则的\textbf{边界符},如sed 在匹配正则时，不仅要指定r, 正则还要以'/'开头
		\subsection{数量限定类}
			\begin{table}[H]
				\centering
				\begin{tabular}{l|m{8cm}|m{7cm}}
					\hline
					\verb|字符 |   	   & \verb|含义| & \verb|例子|\\
					\hline
					\verb|? |   	   & 紧跟在他前面的单元应匹配0次或1次 & \verb|[0-9]?\.[0-9] |匹配 \verb|0.0 2.3  .5|等，特殊字符\verb|.| 需要加转义字符 		\\
					\verb|+ |   	   & 紧跟在他前面的单元应匹配1次或多次 & \verb|[a-zA-Z0-9_-]+ @| \verb|[a-zA-Z0-9_.-]+ \.|\verb|[a-zA-Z0-9_.-]+| 匹配email 地址 \\
					\verb|* |   	   & 紧跟在他前面的单元应匹配0次或多次 & \verb|[0-9]* |匹配至少1位数字	 \\
					\verb|{N}|   	   & 紧跟在他前面的单元应精确匹配N次 & \verb|[1-9][0-9]{2} |匹配100到999的整数	\\
					\verb|{N,}|	  	   & 紧跟在他前面的单元应匹配至少N次 & \verb|[1-9][0-9]{2,} |匹配3位及3位以上的整数   \\
					\verb|{,M}|   	   & 紧跟在他前面的单元应匹配最多M次 & \verb|[0-9]{,1} |最多匹配一次数字	\\
					\verb|{N,M}|	   & 紧跟在他前面的单元应匹配至少N次,最多M次 &  \verb|[0-9]{1,3} |表示0-9数字至少匹配1次，最多匹配3次 \\
					\hline
				\end{tabular}
			\end{table}	
			
		\subsection{位置限定类}
			\begin{table}[H]
					\centering
				\begin{tabular}{l|m{8cm}|m{7cm}}
					\hline
						\verb|字符 |   	   & \verb|含义| & \verb|例子|\\
					\hline
						\verb|^ |   	   & 匹配行首的位置 & 	\verb|^content | 匹配行首为content的行\\
						\verb|$ |   	   & 匹配行末的位置 &  \verb|;$ |匹配行末尾为 \verb|;|的行， \verb|^$ |匹配空行\\
						\verb|\<|   	   & 匹配单词开头的位置 & \verb|\<th |匹配.. this..,但不匹配 tenth等 \\
						\verb|\>|   	   & 匹配单词结尾的位置 & \verb|p\> |匹配leap, 但不匹配 parent\\
						\verb|\b|	  	   & 匹配单词的开头\verb|\bx|或结尾\verb|x\b|的位置 & \verb|\b at|匹配 at,但不匹配 batch\\
						\verb|\B|   	   & 匹配非单词开头\verb|\Bx|或结尾的位置 & \verb|\B at|匹配 battery, 但不匹配 attend、hat\\
					\hline
				\end{tabular}
			\end{table}
		
		\subsection{特殊字符}
			\begin{table}[H]
				\centering
				\begin{tabular}{l|m{8cm}|m{7cm}}
					\hline
					\verb|字符 |   	   & \verb|含义| & \verb|例子|\\
					\hline
					\verb|\ |   	   & 转义字符  & 	\\
					\verb|() |   	   & 将正则表达式的一部分括起来组成一个单元，可以对整个单元使用数量限定符&  \verb|([0-9]{1,3}\.){3}[0-9]{1,3}| 匹配IP地址\\
					|   	   & 链接两个子表达式，表示或的关系 &  \\
					\hline
				\end{tabular}
			\end{table}		
	\section{搜索命令}
		\subparagraph{*文件搜索命令 locate} 通过 \verb|[部分]文件名| 查找\textbf{文件} 的具体位置，搜索速度比\verb|find| 快。在后台数据库中按文件名搜索，搜索数据速度更快，但是后台数据库更新一般是1天更新一次，但是可以使用\verb|updatedb|强制更新后台数据库。
		
			但是使用\verb|updatedb |时遵循\verb|/etc/updatedb.conf|配置文件的规则
			\begin{itemize}[itemindent = 1em]
				\item 开启搜索限制 \verb|PRUNE_BIND_MOUTS = "yes"|
				\item 搜索时，不搜索的文件系统 \verb|PRUNEFS = |
				\item 搜索时，不搜索的文件类型 \verb|PRUNENAMES = |
				\item 搜索时，不搜索的路径 \verb|PRUNEPATHS =|
			\end{itemize}
			
			当配置文件开启搜索规则时，update命令执行后，locate会在搜索时遵照updatedb.conf规则进行剔除搜索。
			
			\textbf{选项}\verb|->|
			\begin{itemize}[itemindent = 1em]
				\item \verb|-i|：忽略大小写
				\item \verb|-c|：不输出文件名，仅计算找到的文件数量
				\item \verb|-l|：仅输出结果的几行，例如输出5行则是 \verb|-l 5|
			\end{itemize}
		
		\subparagraph{*文件搜索命令 find}	在文件系统目录框架中查找文件(\textbf{完全匹配})
		
			\hspace{1cm} \verb|find path -option [-print -delete -ls -quit] [[-exec -ok] command{}[; +]]| 
	
			\begin{table}[H]
				\centering
				\begin{tabular}{l|m{7cm}|m{8cm}}
					\hline
					\verb|find |   	   & \verb|options| & \verb|含义|\\
					\hline
					\verb| |   	   & \verb|-name   filename |& 	查找名为\verb|filename|的文件	\\
					\verb| |   	   & \verb|-perm | & 			按执行权限来查找	\\
					\verb| |   	   & \verb|-user   username | & 按文件属主来查找					\\
					\verb| |   	   & \verb|-group  groupname | &按组来查找 					\\
					\verb|find |   	   & \verb|-mtime  -n +n | & 	按文件更改时间来查找文件，\verb|-n|指\verb|n|天以内，\verb|+n|指\verb|n|天以前				\\
					\verb| |   	   & \verb|-atime  -n +n | &	按文件访问时间来查				\\
					\verb| |   	   & \verb|-ctime  -n +n | & 	按文件创建时间来查找文件，\verb|-n|指\verb|n|天以内，\verb|+n|指\verb|n|天以前				\\
					\verb| |   	   & \verb|-newer  f1 !f2| & 	查更改时间比\verb|f1|新但比\verb|f2|旧的文件				\\
					\verb| |   	   & \verb|-type   b/d/c/p/ll/f |&查是块设备、目录、字符设备、管道、符号链接、普通文件 		\\
					\verb| |   	   & \verb|-size   n[c] | & 	查长度为\verb|n|块[或\verb|n|字节]的文件,\verb|-小于size的，+大于size的|, \verb|find /etc -size +20k -a -size -50k|	\\
					\verb| |	   & \verb|-inum   fileNum|			&   查找文件节点号为fileNum 的文件\\
					\verb| |   	   & \verb|-mount | & 			查文件时不跨越文件系统\verb|mount|点		\\
					\verb| |	   & \verb|-and -or| & \verb|-and|条件与 \verb|-or|条件或\\
					\hline
				\end{tabular}
			\end{table}	
			
			\begin{itemize}
				\item  \verb|-print| 将查找到的文件输出到标准输出
				\item  \verb|-exec   command   {} \;|      —–将查到的文件执行command操作,\verb|{}|为查找的结果，也是新命令的参数。
				\item  \verb|-ok |和\verb|-exec|的作用相同，只不过以一种更为安全的模式来执行该参数所给出的shell命令，在执行每一个命令之前，都会给出提示，让用户来确定是否执行。
			\end{itemize}
			
			\textbf{通配符}\verb|*任意内容  ？任意一个字符  []任意一个括号内的字符|
		
			\hspace{1cm} \url{http://www.cnblogs.com/wanqieddy/archive/2011/06/09/2076785.html}
			
		\subparagraph{*字符串搜索命令 grep} \verb|grep|命令是一种强大的\textbf{文本}搜索工具，它能使用正则表达式搜索文本，并把匹 配的行打印出来。\verb|grep|全称是\verb|Global Regular Expression Print|，表示全局正则表达式版本，它的使用权限是所有用户(\textbf{包含匹配})
		
			\begin{table}[H]
				\centering
				\begin{tabular}{l|m{7cm}|m{8cm}}
					\hline
					\verb|grep |   	   & \verb|options| & \verb|regex pattern|\\
					\hline
					\verb| |   	   & \verb|-c |只输出匹配行的计数 & \verb|\   |忽略正则表达式中特殊字符的原有含义\\
					\verb| |   	   & \verb|-I |不区分大 小写(只适用于单字符) & \verb|^   |匹配正则表达式的开始行\\
					\verb| |       & \verb|-e |并列使用多个 \verb|-e|参数可以实现\textbf{或}条件					& \verb| netstat -an || \verb|grep -e EST -e WAIT|\\
					\verb| |   	   & \verb|-h |查询多文件时不显示文件名 & \verb|$   |匹配正则表达式的结束行\\
					\verb| |   	   & \verb|-l |查询多文件时只输出包含匹配字符的文件名 & \verb|\<  |从匹配正则表达 式的行开始\\
					\verb| |   	   & \verb|-n |显示匹配行及 行号& \verb|\>  |到匹配正则表达式的行结束\\
					\verb| |   	   & \verb|-s |不显示不存在或无匹配文本的错误信息 & \verb|[ ] |单个字符，如[A]即A符合要求\\
					\verb| |   	   & \verb|-v |显示不包含匹配文本的所有行 & \verb|*  | 有字符，长度可以为0\\
					\verb| |   	   & \verb|-R |递归的对目录下的所有文件（包括子目录）进行 grep & \\
					\verb| |   	   & & \verb|[ - ]|范围，如[A-Z]，即A、B、C一直到Z都符合要求\\
					\hline
				\end{tabular}
			\end{table}		
			
		\subparagraph{命令搜索命令 whereis 与 which}
			\verb|which|指令会在环境变量\verb|$PATH|设置的目录里查找符合条件的文件。
			
			\verb|whereis|指令会在特定目录中查找符合条件 的文件。这些文件的属性应属于原始代码，二进制文件，或是帮助文件。
			
		\subparagraph{xargs} 从标准输入中建立、执行命令行,一般结合 管道 | 在结果中使用。
		
			\hspace{1cm} \verb|find ~ -type f -name 'foo*' -print | | \verb|xargs ls -l|

		\subparagraph{stat} 显示文件或文件系统的状态
	
	\section{文本相关}
		\subsection{sed}sed是一个很好的文件处理工具，本身是一个管道命令，主要是\textbf{以行为单位进行处理}，可以将数据行进行替换、删除、新增、选取等特定工作
			
			\verb|sed [options] 'command' 输入文本|
			
			\subparagraph{选项}
				\begin{itemize}[itemindent = 1em]
					\item \verb|-n|∶使用安静(silent)模式。在一般 sed 的用法中，所有来自 STDIN的资料一般都会被列出到萤幕上。但如果加上 -n 参数后，则只有经过sed 特殊处理的那一行(或者动作)才会被列出来。
					
					\item \verb|-e|∶直接在指令列模式上进行 sed 的动作编辑；
					    
					\item \verb|-f|∶直接将 sed 的动作写在一个档案内， -f filename 则可以执行 filename 内的sed 动作；
					
					\item \verb|-r|∶sed 的动作支援的是延伸型正规表示法的语法。(预设是基础正规表示法语法)
					   
					\item \verb|-i|∶直接修改读取的档案内容，而不是由萤幕输出。
				\end{itemize}
			\subparagraph{命令}
				\begin{itemize}[itemindent = 1em]
					 \item \verb|a |  ∶\textbf{新增}， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)
					 \item \verb|c |  ∶\textbf{取代}， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！
					 \item \verb|d |  ∶\textbf{删除}，因为是删除啊，所以 d 后面通常不接任何咚咚；
					 \item \verb|i |  ∶\textbf{插入}， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；
					 \item \verb|p |  ∶\textbf{列印}，亦即将某个选择的资料印出。通常 p 会与参数 sed -n 一起运作
					 \item \verb|s |  ∶\textbf{取代}，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法！例如 \verb|1,20s/old/new/g|
				\end{itemize}
		
		\url{http://www.cnblogs.com/dong008259/archive/2011/12/07/2279897.html}
		
		\subsection{awk}awk是一个非常棒的数字处理工具。相比于sed常常作用于一整行的处理，awk则比较\textbf{倾向于将一行分为数个“字段”来处理}。运行效率高，而且代码简单，对格式化的文本处理能力超强
		
		\url{http://blog.jobbole.com/109089/}	
		
		\subsection{cat} 连接文件并打印到标准输出
			\begin{itemize}
				\item -A, --show-all 等价于 -vET
				\item -b, --number-nonblank 对非空输出行编号
				\item -e 等价于 -vE
				\item -E, --show-ends 在每行结束处显示\verb| $|
				\item -n, --number 对输出的所有行编号
				\item -s, --squeeze-blank 不输出多行空行
				\item -t 与 -vT 等价
				\item -T, --show-tabs 将跳 字符显示为 \verb|^I|
			\end{itemize}
		
		\subsection{sort} 对\textbf{文本行}排序..
		
		\subsection{uniq} 报告并省略重复行
		
		\subsection{cut} 从每一行中移除文本区域
		
		\subsection{paste} 合并文件文本行
		
		\subsection{join} 基于某个共享字段来联合两个文件的 文本行
		
		\subsection{comm} 逐行比较 两个已经排序好 的文件
		
		\subsection{diff} 逐行比较文件
		
		\subsection{patch} 对原文件打补丁
		
		\subsection{tr} 转换或删除 字符
		
		\subsection{aspelx} 交互式拼写检查器
		
		
	\section{归档备份}
		\subsection{压缩与解压缩}常见格式有\verb|.zip  .gz  .bz2  .tar.gz  .tar.bz2|
			
				\begin{itemize}
					\item  \verb|.zip|
						\begin{itemize}
							\item \textbf{压缩} 
								\begin{enumerate}
									\item \verb|zip 压缩文件名  源文件|：压缩文件
									\item \verb|zip -r 压缩文件名 源目录|：压缩目录
								\end{enumerate}
							\item \textbf{解压缩} \verb|unzip 压缩文件|
						\end{itemize}
					
					\item  \verb|.gz|
						\begin{itemize}
							\item \textbf{压缩}
								\begin{enumerate}
									\item \verb|gzip 源文件|：压缩为\verb|.gz|格式的压缩文件，源文件会消失
									\item \verb|gzip -c 源文件 > 压缩文件|：压缩为\verb|.gz|格式，源文件保留
									\item \verb|gzip -r 目录|：压缩目录下所有子文件，但是不能压缩目录
								\end{enumerate}
							\item \textbf{解压缩}
								\begin{enumerate}
									\item \verb|gzip -d 压缩文件|：解压缩文件
									\item \verb|gunzip 压缩文件|：解压缩文件
									\item \verb|解压目录加-r 即可|
								\end{enumerate}
						\end{itemize}
						
					\item  \verb|.bz2|
						\begin{itemize}
							\item \textbf{压缩}，不能压缩目录
								\begin{enumerate}
									\item \verb|bzip2 源文件|：压缩为\verb|.bz2|格式，不保留源文件
									\item \verb|bzip2 -k 源文件|：压缩后保留原文件
								\end{enumerate}
							\item \textbf{解压缩}，加关键字-k 保留压缩文件
								\begin{enumerate}
									\item \verb|bzip2 -d 压缩文件|
									\item \verb|bunzip2 压缩文件|
								\end{enumerate}
						\end{itemize}
					
					\item \textbf{打包}\verb| tar -cvf 打包文件名 源文件|
						\begin{enumerate}
							\item \verb|-c| 打包
							\item \verb|-v| 显示过程
							\item \verb|-f| 指定打包后的文件名
						\end{enumerate}
						
						\verb|tar -cvf long.tar long|
						
						将文件直接打包后压缩为\verb|.tar.gz|格式，-z前缀
						\begin{enumerate}
							\item \verb|-z| \textbf{压缩}为\verb|.tar.gz|:\verb|tar -zcvf 压缩文件名  原文件|
							\item \verb|-x| \textbf{解压缩}\verb|.tar.gz|:\verb|tar -zxvf 压缩包名|
						\end{enumerate}
						
						将文件直接打包后压缩为\verb|.tar.bz2|格式，-j前缀
						\begin{enumerate}
							\item \verb|-z| \textbf{压缩}为\verb|.tar.bz2|:\verb|tar -jcvf 压缩文件名  原文件|
							\item \verb|-x| \textbf{解压缩}\verb|.tar.bz2|:\verb|tar -jxvf 压缩包名|
							\item \verb|-C| 解压到指定路径下\verb|tar -jxvf test.tat.bz2 -C /tmp/|
						\end{enumerate}
						
				\end{itemize}
		
		\subsection{同步文件和目录}
			\paragraph{rsync}在对rsync服务器配置结束以后，下一步就需要在客户端发出rsync命令来实现将服务器端的文件备份到客户端来，但是也可以同步本地的文件夹等，命令格式如下：
				\begin{lstlisting}
rsync [OPTION]... SRC DEST
rsync [OPTION]... SRC [USER@]HOST:DEST
rsync [OPTION]... [USER@]HOST:SRC DEST
rsync [OPTION]... [USER@]HOST::SRC DEST
rsync [OPTION]... SRC [USER@]HOST::DEST
rsync [OPTION]... rsync://[USER@]HOST[:PORT]/SRC [DEST]
				\end{lstlisting}
				
			对应于以上六种命令格式，rsync有六种不同的工作模式：
				\begin{itemize}
					\item 拷贝本地文件。当\verb|SRC|和\verb|DES|路径信息都不包含有单个冒号”\verb|:|”分隔符时就启动这种工作模式。如：\verb|rsync -a /data /backup|
					\item 使用一个远程shell程序(如rsh、ssh)来实现将本地机器的内容拷贝到远程机器。当\verb|DST|路径地址包含单个冒号”\verb|:|”分隔符时启动该模式。如：\verb|rsync -avz *.c foo:src|
					\item 使用一个远程shell程序(如rsh、ssh)来实现将远程机器的内容拷贝到本地机器。当\verb|SRC|地址路径包含单个冒号”\verb|:|”分隔符时启动该模式。如：\verb|rsync -avz foo:src/bar /data|
					\item 从远程rsync服务器中拷贝文件到本地机。当\verb|SRC|路径信息包含”\verb|::|”分隔符时启动该模式。如：\verb|rsync -av root@172.16.78.192::www /databack|
					\item 从本地机器拷贝文件到远程\verb|rsync|服务器中。当\verb|DST|路径信息包含”::”分隔符时启动该模式。如：\verb|rsync -av /databack root@172.16.78.192::www|
					\item 列远程机的文件列表。这类似于\verb|rsync|传输，不过只要在命令中省略掉本地机信息即可。如：\verb|rsync -v rsync://172.16.78.192/www|
				\end{itemize}
				
			\url{http://www.cnblogs.com/subsir/articles/2565373.html}

	
	\section{软件包管理}
		\subsection{已编译文件}
		linux 的文件安装 换句话说就是 把相应的执行文件 拷贝到 系统执行命令的搜索 目录中,即\verb|$PATH| 下，或者在\verb|PATH| 下创建可执行软件的符号链接
		
			\begin{itemize}
				\item 将文件拷贝到\verb|PATH|下任意目录
					\begin{lstlisting}
	INSTALL_DIR=/usr/local/bin
				
	all:
	-@cd src && make
					
	.PHONY: clean
					
	clean:
	-@cd src && make clean
					
	install:
	-cp -f bin/* $(INSTALL_DIR)
					\end{lstlisting}
				\item \verb|ln -s 可执行软件位置  $PATH下任意目录/别名|  ：\verb|ln -s ~/.sublime/sublime_text  ~/bin/subl|
			\end{itemize}
		
		\subsection{源码安装}
			固定3步：
			
			\begin{enumerate}
				\item \verb|./configure|
				\item \verb|make|
				\item \verb|sudo make install|
			\end{enumerate}
	
		\subsection{deb包安装}
			\verb|sudo dpkg -i xx.deb|
			
			\subsubsection{Ubuntu} \verb|sudo apt-get install xx|
			
	\section{参考}
		\url{http://www.linuxcommand.org/index.php}
		
		linux 高级编程:\url{http://guojing.me/linux-kernel-architecture/tags/#do_group_exit}
			


\chapter{其他}

	\section{Shell} 参考 Scripts/Shell 学习笔记	
	
	\section{Linux 系统编程} 参考 linux System Coding 笔记
	
	\section{Linux 网络编程} 参考 linux Network笔记
		
\end{document} 
 		    
