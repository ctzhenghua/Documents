<!DOCTYPE html>
<!-- saved from url=(0039)http://www.tuicool.com/articles/6j2u2qa -->
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta content="authenticity_token" name="csrf-param">
<meta content="1zV8J0iHXP5j8E18xnqiUnFp7GpUVJtqxEMmVU6Actw=" name="csrf-token">
    <title>
            （原创）用C++11的std::async代替线程的创建 - qicosmos - 推酷
   </title>
    <meta name="description" content="（原创）用C++11的std::async代替线程的创建 - qicosmos">
  <link rel="shortcut icon" href="http://static0.tuicool.com/favicon.ico" type="image/x-icon">
  <link href="http://static0.tuicool.com/images/icon114.png" rel="Bookmark">
  <link rel="apple-touch-icon" sizes="57x57" href="http://static1.tuicool.com/images/icon57.png"> 
  <link rel="apple-touch-icon" sizes="72x72" href="http://static2.tuicool.com/images/icon72.png">  
  <link rel="apple-touch-icon" sizes="114x114" href="http://static0.tuicool.com/images/icon114.png">    
  <link rel="apple-touch-icon" sizes="144x144" href="http://static1.tuicool.com/images/icon144.png">
  <link href="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/pub.css" rel="stylesheet">
  <link href="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/application-0432aef4e6fac6447ae7c9a87b77a8e9.css" media="screen" rel="stylesheet" type="text/css">
  <link href="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/font-awesome.min.css" rel="stylesheet">
  <script src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/ca-pub-7054762349007490.js.下载"></script><script type="text/javascript" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/pub.js.下载"></script>
  <script src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/application-59f28b55ce06574657af36ca492c8501.js.下载" type="text/javascript"></script>
    <script type="text/javascript" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/tip.js.下载" async=""></script>
  
  <script type="text/javascript" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/spin.min.js.下载" async=""></script>
    <link rel="stylesheet" href="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/highlight.default.css">
    <style type="text/css">
      .btn-large {
        padding: 0;
      }
      .load-fail {
        display: none;
      }

    </style>

<style type="text/css"></style></head>
<body class=" pace-done"><div class="pace  pace-inactive"><div class="pace-progress" data-progress-text="100%" data-progress="99" style="transform: translate3d(100%, 0px, 0px);">
  <div class="pace-progress-inner"></div>
</div>
<div class="pace-activity"></div></div>
  
  <div id="header" class="navbar-fixed-top">
    <div class="container">
      <div class="navbar">
        <div class="navbar-inner">
          <a class="btn btn-navbar" data-toggle="collapse" data-target=".nav-collapse"> 
            <span class="icon-bar"></span> 
            <span class="icon-bar"></span>
            <span class="icon-bar"></span>
            <span class="icon-bar"></span> 
          </a>
          <a href="http://www.tuicool.com/" class="brand">推酷</a>        
        <nav class="nav-collapse collapse">
            <ul class="nav navbar primary-nav">                            
              <li class="active">
                <a href="http://www.tuicool.com/ah">
                  文章
                </a>
              </li>              
              <li class="">
                <a href="http://www.tuicool.com/sites/hot">
                  站点
                </a>
              </li>
              <li class="">
                <a href="http://www.tuicool.com/topics">
                  主题
                </a>
              </li>
              <li class="">
                <a href="http://huodong.tuicool.com/">
                  活动
                </a>
              </li>
                  <li class="">
                    <a href="http://course.tuicool.com/">
                      公开课
                    </a>
                  </li>
              <li class="">
                <a href="http://www.tuicool.com/mobile">
                  APP
                    <sup style="font-size:0.8em;color: #16A085;">荐</sup>
                </a>
              </li>
              <li class="dropdown">
                <a href="http://www.tuicool.com/articles/6j2u2qa#" class="dropdown-toggle" data-toggle="dropdown">周刊 <b class="caret"></b></a>
                <ul class="dropdown-menu">
                  <li><a href="http://www.tuicool.com/mags">编程狂人</a></li>
                  <li><a href="http://www.tuicool.com/mags/design">设计匠艺</a></li> 
                  <li><a href="http://www.tuicool.com/mags/startup">创业周刊</a></li> 
                  <li><a href="http://www.tuicool.com/mags/tech">科技周刊</a></li>      
                  <li><a href="http://www.tuicool.com/mags/guru">Guru Weekly</a></li> 
                  <li><a href="http://www.tuicool.com/articles/weekly">一周拾遗</a></li>                  
                </ul>
              </li>
              
              </ul>
            <form class="navbar-search pull-left" action="http://www.tuicool.com/search">
              <input type="text" class="search-query span2" name="kw" placeholder="搜索">
            </form>
            <ul class="nav pull-right">
                <li><a href="http://www.tuicool.com/login">登录</a></li>
            </ul>
          </nav>
        </div>
      </div>
  </div>   
</div>
  <div id="flash_container" class="noPrint">    
  </div>
  
  <div class="container-fluid">  
      
<div class="row-fluid article_row_fluid">
    <div class="span8 contant article_detail_bg">
        <h1>（原创）用C++11的std::async代替线程的创建 - qicosmos</h1>
        <div class="article_meta">
            <div style="margin-bottom: 5px;">
            <span class="timestamp">时间&nbsp;2014-01-26 16:40:00
            </span>
            <span class="from">
                <i class="icon-globe"></i>
                    <a class="cut cut28 from" href="http://www.tuicool.com/sites/Fn2umm" target="_blank">博客园-原创精华区
                    </a>
            </span>
            </div>
            <div class="source">
                <i style="float:left;">原文</i>&nbsp; 
                <a class="cut cut70" href="http://www.cnblogs.com/qicosmos/p/3534211.html?utm_source=tuicool&amp;utm_medium=referral" style="display:inline-block;">http://www.cnblogs.com/qicosmos/p/3534211.html</a>
            </div>
            <div>
                <span>主题</span>
                <a href="http://www.tuicool.com/topics/11250022" target="_blank">
                    <span class="new-label">线程</span>
                </a>
                <a href="http://www.tuicool.com/topics/11010001" target="_blank">
                    <span class="new-label">C++</span>
                </a>
            </div>
        </div>
        <div class="article_body" id="nei">
            <div>
  <p>c++11中增加了线程，使得我们可以非常方便的创建线程，它的基本用法是这样的：</p>
  <div>
    <pre class="prettyprint"><span style="color: #0000ff;">void</span> f(<span style="color: #0000ff;">int</span><span style="color: #000000;"> n);
std::thread t(f, n </span>+ <span style="color: #800080;">1</span><span style="color: #000000;">);
t.join();</span></pre>
  </div>
  <p>但是线程毕竟是属于比较低层次的东西，有时候使用有些不便，比如我希望获取线程函数的返回结果的时候，我就不能直接通过thread.join()得到结果，这时就必须定义一个变量，在线程函数中去给这个变量赋值，然后join,最后得到结果，这个过程是比较繁琐的。c++11还提供了异步接口std::async，通过这个异步接口可以很方便的获取线程函数的执行结果。std::async会自动创建一个线程去调用线程函数，它返回一个std::future，这个future中存储了线程函数返回的结果，当我们需要线程函数的结果时，直接从future中获取，非常方便。但是我想说的是，其实std::async给我们提供的便利可不仅仅是这一点，它首先解耦了线程的创建和执行，使得我们可以在需要的时候获取异步操作的结果；其次它还提供了线程的创建策略（比如可以通过延迟加载的方式去创建线程），使得我们可以以多种方式去创建线程。在介绍async具体用法以及为什么要用std::async代替线程的创建之前，我想先说一说std::future、std::promise和std::packaged_task。</p>
  <h2>std::future</h2>
  <p>std::future是一个非常有用也很有意思的东西，简单说std::future提供了一种访问异步操作结果的机制。从字面意思来理解，它表示未来，我觉得这个名字非常贴切，因为一个异步操作我们是不可能马上就获取操作结果的，只能在未来某个时候获取，但是我们可以以同步等待的方式来获取结果，可以通过查询future的状态（future_status）来获取异步操作的结果。future_status有三种状态：</p>
  <ul>
    <li>deferred：异步操作还没开始</li>
    <li>ready：异步操作已经完成</li>
    <li>timeout：异步操作超时</li>
  </ul>
  <div>
    <pre class="prettyprint"><span style="color: #008000;">//</span><span style="color: #008000;">查询future的状态</span>
<span style="color: #000000;">std::future_status status;
    </span><span style="color: #0000ff;">do</span><span style="color: #000000;"> {
        status </span>= future.wait_for(std::chrono::seconds(<span style="color: #800080;">1</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">if</span> (status ==<span style="color: #000000;"> std::future_status::deferred) {
            std::cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">deferred\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (status ==<span style="color: #000000;"> std::future_status::timeout) {
            std::cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">timeout\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (status ==<span style="color: #000000;"> std::future_status::ready) {
            std::cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">ready!\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        }
    } </span><span style="color: #0000ff;">while</span> (status != std::future_status::ready);</pre>
  </div>
  <p>获取future结果有三种方式：get、wait、wait_for，其中get等待异步操作结束并返回结果，wait只是等待异步操作完成，没有返回值，wait_for是超时等待返回结果。</p>
  <h2>std::promise</h2>
  <p>std::promise为获取线程函数中的某个值提供便利，在线程函数中给外面传进来的promise赋值，当线程函数执行完成之后就可以通过promis获取该值了，值得注意的是取值是间接的通过promise内部提供的future来获取的。它的基本用法：</p>
  <div>
    <pre class="prettyprint">std::promise&lt;<span style="color: #0000ff;">int</span>&gt;<span style="color: #000000;"> pr;
    std::thread t([](std::promise</span>&lt;<span style="color: #0000ff;">int</span>&gt;&amp; p){ p.set_value_at_thread_exit(<span style="color: #800080;">9</span>); },std::<span style="color: #0000ff;">ref</span><span style="color: #000000;">(pr));
    std::future</span>&lt;<span style="color: #0000ff;">int</span>&gt; f =<span style="color: #000000;"> pr.get_future();
    auto r </span>= f.<span style="color: #0000ff;">get</span>();</pre>
  </div>
  <h2>std::packaged_task</h2>
  <p>std::packaged_task它包装了一个可调用的目标（如function, lambda expression, bind expression, or another&nbsp;function object）,以便异步调用，它和promise在某种程度上有点像，promise保存了一个共享状态的值，而packaged_task保存的是一个函数。它的基本用法：</p>
  <div>
    <pre class="prettyprint">std::packaged_task&lt;<span style="color: #0000ff;">int</span>()&gt; task([](){ <span style="color: #0000ff;">return</span> <span style="color: #800080;">7</span><span style="color: #000000;">; });
    std::thread t1(std::</span><span style="color: #0000ff;">ref</span><span style="color: #000000;">(task)); 
    std::future</span>&lt;<span style="color: #0000ff;">int</span>&gt; f1 =<span style="color: #000000;"> task.get_future(); 
    auto r1 </span>= f1.<span style="color: #0000ff;">get</span>();</pre>
  </div>
  <h2>std::promise、std::packaged_task和std::future的关系</h2>
  <p>
    至此, 我们介绍了std::async相关的几个对象std::future、std::promise和std::packaged_task，其中std::promise和std::packaged_task的结果最终都是通过其内部的future返回出来的，不知道读者有没有搞糊涂，为什么有这么多东西出来，他们之间的关系到底是怎样的？且听我慢慢道来，std::future提供了一个访问异步操作结果的机制，它和线程是一个级别的属于低层次的对象，在它之上高一层的是std::packaged_task和std::promise，他们内部都有future以便访问异步操作结果，std::packaged_task包装的是一个异步操作，而std::promise包装的是一个值，都是为了方便异步操作的，因为有时我需要获取线程中的某个值，这时就用std::promise，而有时我需要获一个异步操作的返回值，这时就用std::packaged_task。那std::promise和std::packaged_task之间又是什么关系呢？说他们没关系也关系，说他们有关系也有关系，都取决于你了，因为我可以将一个异步操作的结果保存到std::promise中。如果读者还没搞清楚他们的关系的话，我就用更通俗的话来解释一下。比如，一个小伙子给一个姑娘表白真心的时候也许会说：”我许诺    <span>会</span>
    <span>给你一个美好的未来“或者”我会努力奋斗为你创造一个美好的未来“。姑娘往往会说：”我等着“。现在我来将这三句话用c++11来翻译一下：</span>
  </p>
  <p>
    小伙子说：我许诺会给你一个美好的未来等于c++11中"std::promise a std::future";    <br>
    小伙子说：我会努力奋斗为你创造一个美好的未来等于c++11中"std::packaged_task a future";    <br>
    姑娘说：我等着等于c++11中"future.get()/wait()";  </p>
  <p>小伙子两句话的个中差异，自己琢磨一下，这点差异也是std::promise和std::packaged_task的差异。现实中的山盟海誓靠不靠得住我不知道，但是c++11中的许诺和未来是一定可靠的，发起来了许诺就一定有未来。细想起来c++11标准的制定者选定的关键字真是贴切而有意思！好了，插科打诨到此了，现在言归正传，回过头来说说std::async。</p>
  <h2>为什么要用std::async代替线程的创建</h2>
  <p>std::async又是干啥的，已经有了td::future、std::promise和std::packaged_task，够多的了，真的还要一个std::async来凑热闹吗，std::async表示很委屈：我不是来凑热闹的，我是来帮忙的。是的，std::async是为了让用户的少费点脑子的，它让这三个对象默契的工作。大概的工作过程是这样的：std::async先将异步操作用std::packaged_task包装起来，然后将异步操作的结果放到std::promise中，这个过程就是创造未来的过程。外面再通过future.get/wait来获取这个未来的结果，怎么样，std::async真的是来帮忙的吧，你不用再想到底该怎么用std::future、std::promise和std::packaged_task了，std::async已经帮你搞定一切了！</p>
  <p>现在来看看std::async的原型async(std::launch::async | std::launch::deferred, f, args...)，第一个参数是线程的创建策略，有两种策略，默认的策略是立即创建线程：</p>
  <ul>
    <li>std::launch::async：在调用async就开始创建线程。</li>
    <li>std::launch::deferred：延迟加载方式创建线程。调用async时不创建线程，直到调用了future的get或者wait时才创建线程。</li>
  </ul>
  <p>第二个参数是线程函数，第三个参数是线程函数的参数。</p>
  <p>
    <br>
    <strong>std::async基本用法：</strong>
  </p>
  <div>
    <pre class="prettyprint">std::future&lt;<span style="color: #0000ff;">int</span>&gt; f1 =<span style="color: #000000;"> std::async(std::launch::async, [](){ 
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">8</span><span style="color: #000000;">;  
    }); 

cout</span>&lt;&lt;f1.<span style="color: #0000ff;">get</span>()&lt;&lt;endl; <span style="color: #008000;">//</span><span style="color: #008000;">output: 8</span>
<span style="color: #000000;">
std::future</span>&lt;<span style="color: #0000ff;">int</span>&gt; f2 =<span style="color: #000000;"> std::async(std::launch::async, [](){ 
        cout</span>&lt;&lt;<span style="color: #800080;">8</span>&lt;&lt;<span style="color: #000000;">endl;
    }); 

f2.wait(); </span><span style="color: #008000;">//</span><span style="color: #008000;">output: 8</span>
<span style="color: #000000;">
std::future</span>&lt;<span style="color: #0000ff;">int</span>&gt; future =<span style="color: #000000;"> std::async(std::launch::async, [](){ 
        std::this_thread::sleep_for(std::chrono::seconds(</span><span style="color: #800080;">3</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">return</span> <span style="color: #800080;">8</span><span style="color: #000000;">;  
    }); 
 
    std::cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">waiting...\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
    std::future_status status;
    </span><span style="color: #0000ff;">do</span><span style="color: #000000;"> {
        status </span>= future.wait_for(std::chrono::seconds(<span style="color: #800080;">1</span><span style="color: #000000;">));
        </span><span style="color: #0000ff;">if</span> (status ==<span style="color: #000000;"> std::future_status::deferred) {
            std::cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">deferred\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (status ==<span style="color: #000000;"> std::future_status::timeout) {
            std::cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">timeout\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        } </span><span style="color: #0000ff;">else</span> <span style="color: #0000ff;">if</span> (status ==<span style="color: #000000;"> std::future_status::ready) {
            std::cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">ready!\n</span><span style="color: #800000;">"</span><span style="color: #000000;">;
        }
    } </span><span style="color: #0000ff;">while</span> (status !=<span style="color: #000000;"> std::future_status::ready); 
 
    std::cout </span>&lt;&lt; <span style="color: #800000;">"</span><span style="color: #800000;">result is </span><span style="color: #800000;">"</span> &lt;&lt; future.<span style="color: #0000ff;">get</span>() &lt;&lt; <span style="color: #800000;">'</span><span style="color: #800000;">\n</span><span style="color: #800000;">'</span><span style="color: #000000;">;
可能的结果：
waiting...
timeout
timeout
ready</span>!<span style="color: #000000;">
result </span><span style="color: #0000ff;">is</span> <span style="color: #800080;">8</span></pre>
  </div>
  <h2>总结：</h2>
  <p>std::async是更高层次上的异步操作，使我们不用关注线程创建内部细节，就能方便的获取异步执行状态和结果，还可以指定线程创建策略，应该用std::async替代线程的创建，让它成为我们做异步操作的首选。</p>
  <p>如果你觉得这篇文章对你有用，可以点一下推荐，谢谢。</p>
  <p>c++11 boost技术交流群：296561497，欢迎大家来交流技术。</p>
</div>

        </div>
        <div class="article_social">
         <div class="article_like">
    <div class="circle circle-like" id="my_zan" data_id="6j2u2qa">  </div>

</div>
        <div id="share_weixin_image">
            <img width="100px" height="100px" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/qrcode.php">
        </div>
<div class="article_share_fav">
    <div class="share" id="ckepop">
        <span>分享</span>
        <button class="share_weibo" id="share_weibo_id" title="分享到新浪微博"></button>
        <button class="share_qq" id="share_qq_id" title="分享到QQ空间"></button>
        <button class="share_weixin" id="share_weixin_id"></button>
    </div>
    <div class="fav_correct">
        <button id="my_fav" data_id="6j2u2qa">
            <i class="icon icon-star-empty"></i> <span id="fav_tip">收藏</span>
        </button>
        <button id="article-correct" data_id="6j2u2qa" uid="0">
            <i class="icon icon-warning-sign"></i>
            <span>纠错</span>
        </button>
    </div>
</div>
<script type="text/javascript">
$("#share_weibo_id").click( function() {
   window.open("http://share.baidu.com/s?type=text&searchPic=0&sign=on&to=tsina&url=http://www.tuicool.com/articles/6j2u2qa&title=%EF%BC%88%E5%8E%9F%E5%88%9B%EF%BC%89%E7%94%A8C%2B%2B11%E7%9A%84std%3A%3Aasync%E4%BB%A3%E6%9B%BF%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA+-+qicosmos++%28%E5%88%86%E4%BA%AB%E8%87%AA+%40%E6%8E%A8%E9%85%B7%E7%BD%91%29&key=3113829255");
});
$("#share_qq_id").click( function() {
   window.open("http://sns.qzone.qq.com/cgi-bin/qzshare/cgi_qzshare_onekey?url=http://www.tuicool.com/articles/6j2u2qa&title=%EF%BC%88%E5%8E%9F%E5%88%9B%EF%BC%89%E7%94%A8C%2B%2B11%E7%9A%84std%3A%3Aasync%E4%BB%A3%E6%9B%BF%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%88%9B%E5%BB%BA+-+qicosmos&desc=&summary=&site=");
});
$("#share_weixin_id").click( function() {
  $("#share_weixin_image").toggle();
});
</script>


            <div class="bottom_plink huodong-detail-plink-banner clearfix">
                    <a href="http://click.aliyun.com/m/5708/" target="_blank"><img src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/aliyun_mag.jpg"></a>

            </div>
        </div>
        <div id="site_articles" style="clear:both;">
              <div class="article-part-title">
                <span>推荐文章</span>
              </div>
          <ul class="side_article_list">
                <li class="side_article_list_item">
                    1.<a href="http://www.tuicool.com/articles/vmURNfV" target="_blank" title="用户态同步之自旋锁">
                    用户态同步之自旋锁
                    </a>
                </li>
                <li class="side_article_list_item">
                    2.<a href="http://www.tuicool.com/articles/zuAzeui" target="_blank" title="关于面试常见算法与数据结构的实现（开源项目）">
                    关于面试常见算法与数据结构的实现（开源项目）
                    </a>
                </li>
                <li class="side_article_list_item">
                    3.<a href="http://www.tuicool.com/articles/6VrUzan" target="_blank" title="看看所谓的 Zero cost abstraction">
                    看看所谓的 Zero cost abstraction
                    </a>
                </li>
                <li class="side_article_list_item">
                    4.<a href="http://www.tuicool.com/articles/73IfQj" target="_blank" title="内存溢出 ≠ 内存不足">
                    内存溢出 ≠ 内存不足
                    </a>
                </li>
                <li class="side_article_list_item">
                    5.<a href="http://www.tuicool.com/articles/neQVvu2" target="_blank" title="[译] C++中带状态元编程黑科技（二）：实现常量表达式计数器">
                    [译] C++中带状态元编程黑科技（二）：实现常量表达式计数器
                    </a>
                </li>
                <li class="side_article_list_item">
                    6.<a href="http://www.tuicool.com/articles/mQzANfZ" target="_blank" title="【LeetCode】205. Isomorphic Strings">
                    【LeetCode】205. Isomorphic Strings
                    </a>
                </li>
          </ul>
        </div>
        <div id="kan_articles"> <div class="article-part-title"> <span>相关推刊</span></div><div class="kan-list-container"><ul class="kan-list clearfix">          <li class="kan-item">            <a href="http://www.tuicool.com/kans/3722220278" target="_blank" class="kan-item-head">              <small>by 姓魏名坤</small>              <img class="kan-cover" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/default_kan_cover.png">            </a>            <span class="kan-detail">              <a href="http://www.tuicool.com/kans/3722220278" target="_blank">《c++11》</a>              <i class="kan-num">1</i>            </span>          </li>                  <li class="kan-item">            <a href="http://www.tuicool.com/kans/303324164" target="_blank" class="kan-item-head">              <small>by dipperkun</small>              <img class="kan-cover" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/jQ3YRvM.png!kan">            </a>            <span class="kan-detail">              <a href="http://www.tuicool.com/kans/303324164" target="_blank">《默认推刊》</a>              <i class="kan-num">16136</i>            </span>          </li>        </ul></div><i class="clearfix"></i></div>
        <div id="article_weibo" style="display:none;">
            <div class="article-part-title">
                <span>相关微博</span>
                <sub>
                    <a href="http://www.tuicool.com/articles/weibo_list/6j2u2qa" target="_blank">(<i id="weibo_num"></i>)</a> 
               </sub>
            </div>
            <div class="related-weibo-list"></div>
        </div>
        <div class="comments">
    <div class="comments-area">
    <div class="comments-header">
        <h5>我来评几句</h5>
        <div class="alert comment-alert alert-error" style="display:none;">
            错误
        </div>
            <textarea cols="60" rows="5" id="comment-body" placeholder="请输入评论内容..." style="resize: none;"></textarea>
            <span class="btn btn-medium btn-submit" id="comment-submit">登录后评论</span>
        <p style="margin-top: 5px;margin-left:10px;">
            已发表评论数(<span class="comment_cnt"></span>)
        </p>
    </div>
    <div class="comments-list">
        <div class="empty-cmts alert alert-success" style="display:none;">
            没有更多评论了^^
        </div>
    </div>
    <div class="more-comments" style="display:none;">
        <a href="http://www.tuicool.com/articles/6j2u2qa">更多评论</a>
    </div>
    <div class="load-fail" style="display:none;">
        评论加载失败，<a href="javascript:reload_comments(&#39;6j2u2qa&#39;,1,0,-1);">重新加载</a>
    </div>
    </div>
</div>

    </div>
        <div class="span4 article_right_side">
            <div class="right_top">
    <div class="article_related_site article_detail_bg">
    <h4 class="article-part-title">相关站点</h4>
    <div class="article_related_site_body clearfix">
        <div class="logo">
            <img src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/Fn2umm.png">
        </div>
        <div class="name">
            <div>
                <a href="http://www.tuicool.com/sites/Fn2umm" target="_blank"> 博客园-原创精华区</a>
            </div>
            <div>
                <div class="btn btn-success right_site_follow" id="my_follow" data_id="Fn2umm">＋订阅</div>
            </div>
        </div>
    </div>
</div>

<div id="right_site_articles" class="article_detail_bg">
    <div class="article-part-title">
        <span>热门文章</span>
    </div>
    <ul class="side_article_list">
        <li class="side_article_list_item">
            1.<a href="http://www.tuicool.com/articles/JRRzUj7" target="_blank" title="Cpp 编码风格指南"> Cpp 编码风格指南 </a>
        </li>
        <li class="side_article_list_item">
            2.<a href="http://www.tuicool.com/articles/zuAzeui" target="_blank" title="关于面试常见算法与数据结构的实现（开源项目）"> 关于面试常见算法与数据结构的实现（开源项目） </a>
        </li>
        <li class="side_article_list_item">
            3.<a href="http://www.tuicool.com/articles/6VrUzan" target="_blank" title="看看所谓的 Zero cost abstraction"> 看看所谓的 Zero cost abstraction </a>
        </li>
        <li class="side_article_list_item">
            4.<a href="http://www.tuicool.com/articles/neQVvu2" target="_blank" title="[译] C++中带状态元编程黑科技（二）：实现常量表达式计数器"> [译] C++中带状态元编程黑科技（二）：实现常量表达式计数器 </a>
        </li>
        <li class="side_article_list_item">
            5.<a href="http://www.tuicool.com/articles/eiaAv2b" target="_blank" title="总说 c++ 写底层,但是底层是什么,c++ 怎么写?"> 总说 c++ 写底层,但是底层是什么,c++ 怎么写? </a>
        </li>
    </ul>
</div>


      <div class="right-link">
                <a href="http://click.aliyun.com/m/9775/" target="_blank"><img src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/aliyun120.jpg"></a>

      </div>
      <div class="right-link" style="margin-top: 5px">
                <a href="https://sspaas.com/" target="_blank"><img src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/sspaas320.jpg"></a>

      </div>
      <div class="right-link" style="margin-top: 5px">
                <a href="https://www.mysubmail.com/sms?s=tuicool" target="_blank"><img src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/submail120.jpg"></a>

      </div>
</div>
<div class="operate_zone" style="position: inherit; top: 0px;">
        <div class="frd_pos">
        <script async="" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/adsbygoogle.js.下载"></script>
<ins class="adsbygoogle" style="display: inline-block; width: 300px; height: 250px;" data-ad-client="ca-pub-7054762349007490" data-ad-slot="5705695566" data-adsbygoogle-status="done"><ins id="aswift_0_expand" style="display:inline-table;border:none;height:250px;margin:0;padding:0;position:relative;visibility:visible;width:300px;background-color:transparent"><ins id="aswift_0_anchor" style="display:block;border:none;height:250px;margin:0;padding:0;position:relative;visibility:visible;width:300px;background-color:transparent"><iframe width="300" height="250" frameborder="0" marginwidth="0" marginheight="0" vspace="0" hspace="0" allowtransparency="true" scrolling="no" allowfullscreen="true" onload="var i=this.id,s=window.google_iframe_oncopy,H=s&amp;&amp;s.handlers,h=H&amp;&amp;H[i],w=this.contentWindow,d;try{d=w.document}catch(e){}if(h&amp;&amp;d&amp;&amp;(!d.body||!d.body.firstChild)){if(h.call){setTimeout(h,0)}else if(h.match){try{h=s.upd(h,i)}catch(e){}w.location.replace(h)}}" id="aswift_0" name="aswift_0" style="left:0;position:absolute;top:0;" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/saved_resource.html"></iframe></ins></ins></ins>
<script>
(adsbygoogle = window.adsbygoogle || []).push({});
</script>

        </div>
</div>
         </div>
</div>

<div>
   <!-- add_article to kan -->
<div id="add-article-to-kan" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
  <div class="modal-header">
    <span class="add-title">收藏到推刊</span>
    <a href="http://www.tuicool.com/articles/6j2u2qa#new-kan" class="btn pull-right" data-toggle="modal">创建推刊</a>
    <i class="clearfix"></i>
  </div>
  <div class="modal-body">
    <ul id="add-kan-list">
    </ul>
  </div>
  <div class="modal-footer">
    <input type="hidden" value="6j2u2qa" class="article-id"> 
    <button class="btn btn-primary pull-left add-to-btn">  收 藏  </button>
    <button class="btn" data-dismiss="modal" aria-hidden="true" style="margin-right: 15px">取消</button>
  </div>
</div>

   <div id="new-kan" class="modal hide fade" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="true">
  <div class="modal-body">
    <input type="text" name="name" id="new-kan-name" placeholder="推刊名(必填)" required="" data-validation-required-message="请填写推刊名">
    <span class="new-ness-name">请填写推刊名</span>
    <br>
    <textarea name="desc" id="desc" rows="6" placeholder="推刊描述"></textarea>
    <span class="new-ness-desc">描述不能大于100个字符!</span>
    <br>
    权限设置：<input type="radio" name="type" value="1" checked="checked"> 公开
    <input type="radio" name="type" value="0"> 仅自己可见
  </div>
  <div class="modal-footer">
    <button class="btn btn-primary pull-left create-kan-btn" disabled="">创建</button>
    <button class="btn dismiss-new-kan" data-dismiss="modal" aria-hidden="true">取消</button>
  </div>
</div>


</div>
<div id="article-correct-modal" class="modal hide fade in" tabindex="-1" role="dialog" aria-labelledby="myModalLabel" aria-hidden="false">
    <div class="modal-header">
        <button type="button" class="close" data-dismiss="modal" aria-hidden="true">
            ×
        </button>
        <h3>文章纠错</h3>
    </div>
    <div class="modal-body">
        <input type="hidden" value="6j2u2qa" id="article-correct-source">
        <div>
            <label for="article-correct-email">
                邮箱地址
            </label>
            <input type="email" id="article-correct-email" class="input-large">
        </div>
        <div>
            <label for="article-correct-select">
                错误类型
            </label>
            <select id="article-correct-select">
                <option value="正文不准确">正文不准确</option>
                <option value="标题不准确">标题不准确</option>
                <option value="排版有问题">排版有问题</option>
                <option value="排版有问题">主题不准确</option>
                <option value="没有分页内容">没有分页内容</option>
                <option value="图片无法显示">图片无法显示</option>
                <option value="视频无法显示">视频无法显示</option>
                <option value="与原文不一致">与原文不一致</option>
            </select>
        </div>
        <div>
            <label for="article-correct-other">
                补充信息
            </label>
            <textarea id="article-correct-other" class="span4"></textarea>
        </div>
    </div>
    <div class="modal-footer">
        <button class="btn btn-primary pull-right huodong_correct_submit" id="article-correct-submit">
            &nbsp;&nbsp;提交&nbsp;&nbsp;
        </button>
    </div>
</div>


<script src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/highlight.pack.js.下载"></script>
<script type="text/javascript">
    $('table').each(function(i) {
        var size = $(this).children().size();
        if (size > 1) {
            $(this).attr('class',"table table-bordered");
        } else if (size == 1) {
            var e11 = $(this).children(":first");
            var e1 = e11[0];
            var name = e1.nodeName.toLowerCase();
            if ("tbody" == name) {
                if (e1.children.length > 1) {
                    $(this).attr('class',"table table-bordered");
                } else if (e1.children.length == 1){
                    var e12 = e1.children[0];
                    var name2 = e12.nodeName.toLowerCase();
                    if ("tr" == name2) {
                       if (e12.children.length > 1) {
                         $(this).attr('class',"table table-bordered");
                       }
                    }
                }
            }
        }
    });
            related_kan("6j2u2qa");
        window.page = 0;
        window.last = 0;    
        window.first = true;
        resize_article_image('#nei', 550);
                load_comments("6j2u2qa",1,0,-1);
                window.uid = -1;
        open_add_article_to_kan("false");
        async_do_zan_article();
        $('pre').each(function(i, e) {
            hljs.highlightBlock(e, "<span class='indent'>  </span>", false)
        });
       
          
       handle_follow_site("#my_follow","已订阅","+ 订阅");
</script>


    <div class="loader-inner ball-pulse ball-loading-center" id="page-loading" style="display: none">
      <div></div>
      <div></div>
      <div></div>
    </div>
    <div class="read-later-alert"></div>
  </div>

        <div class="footer">
      <div class="footer-inner" style="padding-top: 50px;padding-bottom: 50px">
        <a href="http://www.tuicool.com/about" target="_blank">关于我们</a>
        <a href="http://www.tuicool.com/mobile" target="_blank">移动应用</a>
        <a href="http://www.tuicool.com/bbs/go/issues" target="_blank">意见反馈</a>
        <a target="_blank" href="http://e.weibo.com/tuicool2012">官方微博</a>
      </div>
    </div>
    <div style="display:none;">
      <script src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/stat.php" language="JavaScript"></script><script src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/core.php" charset="utf-8" type="text/javascript"></script><a href="http://www.cnzz.com/stat/website.php?web_id=5541078" target="_blank" title="站长统计"><img border="0" hspace="0" vspace="0" src="./（原创）用C++11的std__async代替线程的创建 - qicosmos - 推酷_files/pic.gif"></a>
    </div>




<div class="return" title="返回顶部" style="display: none;"></div></body></html>