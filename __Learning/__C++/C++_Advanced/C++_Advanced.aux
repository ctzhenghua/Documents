\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand*\HyPL@Entry[1]{}
\HyPL@Entry{0<</S/D>>}
\@writefile{toc}{\contentsline {chapter}{\numberline {第一章\hspace  {0.3em}}正则表达式}{9}{chapter.1}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {1.1}基础知识}{9}{section.1.1}}
\@writefile{toc}{\contentsline {subparagraph}{头文件}{9}{section*.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1.1}整个字符串是否匹配}{9}{subsection.1.1.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1.2}只返回一个匹配结果}{9}{subsection.1.1.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {1.1.3}返回多个匹配结果}{9}{subsection.1.1.3}}
\@writefile{toc}{\contentsline {section}{\numberline {1.2}子表达式匹配}{10}{section.1.2}}
\@writefile{toc}{\contentsline {chapter}{\numberline {第二章\hspace  {0.3em}}异常处理}{13}{chapter.2}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {2.1}简介}{13}{section.2.1}}
\@writefile{toc}{\contentsline {paragraph}{编写流程}{13}{section*.3}}
\@writefile{toc}{\contentsline {section}{\numberline {2.2}异常处理机制}{14}{section.2.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.1}异常再引发}{14}{subsection.2.2.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.2}栈展开}{14}{subsection.2.2.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.1}{\ignorespaces 流程演示}}{15}{figure.2.1}}
\newlabel{process_error}{{2.1}{15}{流程演示}{figure.2.1}{}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.3}未处理异常}{15}{subsection.2.2.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.4}描述函数可否引发异常}{16}{subsection.2.2.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.5}显示异常名字}{16}{subsection.2.2.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.2.6}异常标准库类结构}{18}{subsection.2.2.6}}
\@writefile{lof}{\contentsline {figure}{\numberline {2.2}{\ignorespaces Exception 层次结构}}{18}{figure.2.2}}
\@writefile{toc}{\contentsline {section}{\numberline {2.3}logic\_error}{19}{section.2.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.1}invalid\_argument}{19}{subsection.2.3.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.2}domain\_error}{19}{subsection.2.3.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.3}length\_error}{19}{subsection.2.3.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.4}out\_of\_range}{19}{subsection.2.3.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.5}future\_error}{19}{subsection.2.3.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.3.6}bad\_optional\_access}{20}{subsection.2.3.6}}
\@writefile{toc}{\contentsline {section}{\numberline {2.4}runtime\_error}{20}{section.2.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4.1}range\_error}{20}{subsection.2.4.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4.2}overflow\_error}{20}{subsection.2.4.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4.3}underflow\_error}{20}{subsection.2.4.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4.4}regex\_error}{21}{subsection.2.4.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4.5}system\_error}{21}{subsection.2.4.5}}
\@writefile{toc}{\contentsline {subsubsection}{ios\_base::failure}{21}{section*.4}}
\@writefile{toc}{\contentsline {subsubsection}{filesystem::filesystem\_error}{22}{section*.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.4.6}tx\_exception}{22}{subsection.2.4.6}}
\@writefile{toc}{\contentsline {section}{\numberline {2.5}bad errors}{22}{section.2.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5.1}bad\_typeid}{22}{subsection.2.5.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5.2}bad\_cast}{23}{subsection.2.5.2}}
\@writefile{toc}{\contentsline {subsubsection}{bad\_any\_cast}{23}{section*.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5.3}bad\_weak\_ptr}{23}{subsection.2.5.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5.4}bad\_function\_call}{23}{subsection.2.5.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5.5}bad\_alloc}{24}{subsection.2.5.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5.6}bad\_exception}{24}{subsection.2.5.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.5.7}bad\_variant\_access}{25}{subsection.2.5.7}}
\@writefile{toc}{\contentsline {chapter}{\numberline {第三章\hspace  {0.3em}}多线程}{27}{chapter.3}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {3.1}参考}{27}{section.3.1}}
\@writefile{toc}{\contentsline {section}{\numberline {3.2}须知}{27}{section.3.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.1}线程安全}{27}{subsection.3.2.1}}
\@writefile{toc}{\contentsline {subparagraph}{线程安全的条件}{27}{section*.7}}
\@writefile{toc}{\contentsline {subparagraph}{线程安全的类}{28}{section*.8}}
\@writefile{toc}{\contentsline {subparagraph}{对象的race condition}{28}{section*.9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.2.2}对象的创建}{28}{subsection.3.2.2}}
\@writefile{toc}{\contentsline {section}{\numberline {3.3}概念}{28}{section.3.3}}
\@writefile{toc}{\contentsline {subparagraph}{内核线程}{28}{section*.10}}
\@writefile{toc}{\contentsline {subparagraph}{轻量级进程}{28}{section*.11}}
\@writefile{toc}{\contentsline {subparagraph}{用户线程}{28}{section*.12}}
\@writefile{toc}{\contentsline {subparagraph}{进程与线程的比较}{29}{section*.13}}
\@writefile{toc}{\contentsline {section}{\numberline {3.4}POSIX线程}{29}{section.3.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4.1}线程创建}{29}{subsection.3.4.1}}
\@writefile{toc}{\contentsline {subparagraph}{线程创建函数}{29}{section*.14}}
\@writefile{toc}{\contentsline {subparagraph}{线程创建流程}{29}{section*.15}}
\@writefile{toc}{\contentsline {subparagraph}{线程创建说明}{29}{section*.16}}
\@writefile{toc}{\contentsline {subparagraph}{线程退出方式}{30}{section*.17}}
\@writefile{toc}{\contentsline {subparagraph}{示例代码}{30}{section*.18}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4.2}线程ID}{30}{subsection.3.4.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4.3}线程属性}{30}{subsection.3.4.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4.4}线程撤销}{30}{subsection.3.4.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4.5}线程局部存储}{30}{subsection.3.4.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.4.6}线程清除}{30}{subsection.3.4.6}}
\@writefile{toc}{\contentsline {section}{\numberline {3.5}C++11线程}{30}{section.3.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.5.1}头文件}{30}{subsection.3.5.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.5.2}线程类}{31}{subsection.3.5.2}}
\@writefile{lof}{\contentsline {figure}{\numberline {3.1}{\ignorespaces Thread Pattern}}{31}{figure.3.1}}
\@writefile{toc}{\contentsline {subparagraph}{初始化方式..}{32}{section*.19}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.5.3}线程间数据交互和数据争用(Data Racing)}{35}{subsection.3.5.3}}
\@writefile{toc}{\contentsline {subparagraph}{解决方案：}{36}{section*.20}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.5.4}互斥锁}{38}{subsection.3.5.4}}
\@writefile{toc}{\contentsline {subsubsection}{Mutex}{39}{section*.21}}
\@writefile{toc}{\contentsline {subparagraph}{lock\_guard<T\_mutex> m(T\_mutex)}{39}{section*.22}}
\@writefile{toc}{\contentsline {subparagraph}{unique\_lock<T\_mutex> m(T\_mutex)}{39}{section*.23}}
\@writefile{toc}{\contentsline {subparagraph}{Recursice\_mutex}{40}{section*.24}}
\@writefile{toc}{\contentsline {subsubsection}{Call once}{41}{section*.25}}
\@writefile{toc}{\contentsline {subparagraph}{注意：}{42}{section*.26}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.5.5}条件变量}{42}{subsection.3.5.5}}
\@writefile{toc}{\contentsline {subparagraph}{condition\_variable}{42}{section*.27}}
\@writefile{toc}{\contentsline {subparagraph}{conditon\_variable\_any}{44}{section*.28}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.5.6}期许与承诺}{44}{subsection.3.5.6}}
\@writefile{toc}{\contentsline {paragraph}{线程的返回值}{44}{section*.29}}
\@writefile{toc}{\contentsline {subsubsection}{指针型式参数}{44}{section*.30}}
\@writefile{toc}{\contentsline {subsubsection}{期许future}{45}{section*.31}}
\@writefile{toc}{\contentsline {subparagraph}{理论}{46}{section*.32}}
\@writefile{toc}{\contentsline {subsubsection}{承诺promise}{47}{section*.33}}
\@writefile{toc}{\contentsline {subparagraph}{理论}{49}{section*.34}}
\@writefile{toc}{\contentsline {subsubsection}{packaged\_task}{50}{section*.35}}
\@writefile{toc}{\contentsline {subsubsection}{参考}{51}{section*.36}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.5.7}线程池}{51}{subsection.3.5.7}}
\@writefile{toc}{\contentsline {subsubsection}{应用场景}{51}{section*.37}}
\@writefile{toc}{\contentsline {subsubsection}{实现}{51}{section*.38}}
\@writefile{toc}{\contentsline {subsubsection}{实现原理}{55}{section*.39}}
\@writefile{toc}{\contentsline {subsubsection}{参考}{55}{section*.40}}
\@writefile{toc}{\contentsline {section}{\numberline {3.6}References}{55}{section.3.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.1}thread}{55}{subsection.3.6.1}}
\@writefile{toc}{\contentsline {subsubsection}{consturcting Threads}{55}{section*.41}}
\@writefile{toc}{\contentsline {subsubsection}{Detach thread}{57}{section*.42}}
\@writefile{toc}{\contentsline {subsubsection}{Get thread id}{57}{section*.43}}
\@writefile{toc}{\contentsline {subsubsection}{Join thread}{58}{section*.44}}
\@writefile{toc}{\contentsline {subsubsection}{Check if joinable}{59}{section*.45}}
\@writefile{toc}{\contentsline {subsubsection}{Move-assign thread:operator=}{60}{section*.46}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.2}atomic}{61}{subsection.3.6.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.3}mutex}{62}{subsection.3.6.3}}
\@writefile{toc}{\contentsline {subsubsection}{Mutex types}{62}{section*.47}}
\@writefile{toc}{\contentsline {subsubsection}{Locks}{63}{section*.48}}
\@writefile{toc}{\contentsline {subsubsection}{Functions}{66}{section*.49}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.4}condition\_variable}{67}{subsection.3.6.4}}
\@writefile{toc}{\contentsline {subparagraph}{notify\_one}{68}{section*.50}}
\@writefile{toc}{\contentsline {subparagraph}{Wait for timeout or until notified}{70}{section*.51}}
\@writefile{toc}{\contentsline {subparagraph}{Data Races}{71}{section*.52}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.6.5}Futures}{71}{subsection.3.6.5}}
\@writefile{toc}{\contentsline {subsubsection}{future}{72}{section*.53}}
\@writefile{toc}{\contentsline {subparagraph}{Get value}{73}{section*.54}}
\@writefile{toc}{\contentsline {subparagraph}{Get shared future}{73}{section*.55}}
\@writefile{toc}{\contentsline {subparagraph}{Check for valid shared state}{74}{section*.56}}
\@writefile{toc}{\contentsline {subparagraph}{Wait for ready}{75}{section*.57}}
\@writefile{toc}{\contentsline {subparagraph}{Wait for ready during time span}{76}{section*.58}}
\@writefile{toc}{\contentsline {subsubsection}{shared\_future}{77}{section*.59}}
\@writefile{toc}{\contentsline {subsubsection}{promise}{77}{section*.60}}
\@writefile{toc}{\contentsline {subparagraph}{Set value}{78}{section*.61}}
\@writefile{toc}{\contentsline {chapter}{\numberline {第四章\hspace  {0.3em}}多进程}{79}{chapter.4}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {chapter}{\numberline {第五章\hspace  {0.3em}}泛型编程}{81}{chapter.5}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {5.1}decltype}{81}{section.5.1}}
\@writefile{toc}{\contentsline {section}{\numberline {5.2}完美转发}{81}{section.5.2}}
\@writefile{toc}{\contentsline {section}{\numberline {5.3}前言须知}{82}{section.5.3}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.1}{\ignorespaces Error： 没包含cpp文件}}{82}{figure.5.1}}
\@writefile{lof}{\contentsline {figure}{\numberline {5.2}{\ignorespaces 解决LNK2019 问题}}{82}{figure.5.2}}
\@writefile{toc}{\contentsline {paragraph}{特点}{83}{section*.62}}
\@writefile{toc}{\contentsline {paragraph}{用途}{83}{section*.63}}
\@writefile{toc}{\contentsline {section}{\numberline {5.4}函数模版}{83}{section.5.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.1}定义及使用}{83}{subsection.5.4.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.2}声明模版函数}{83}{subsection.5.4.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.3}模版也可以重载}{83}{subsection.5.4.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.4}实参的演绎-模版类型推导确定}{83}{subsection.5.4.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.4.5}定制非模版函数(重载函数模版)}{84}{subsection.5.4.5}}
\@writefile{toc}{\contentsline {section}{\numberline {5.5}函子}{85}{section.5.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.5.1}函数指针实现}{85}{subsection.5.5.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.5.2}函子}{85}{subsection.5.5.2}}
\@writefile{toc}{\contentsline {subparagraph}{目的}{85}{section*.64}}
\@writefile{toc}{\contentsline {subparagraph}{优点}{85}{section*.65}}
\@writefile{toc}{\contentsline {subparagraph}{例子}{86}{section*.66}}
\@writefile{toc}{\contentsline {section}{\numberline {5.6}类模板}{86}{section.5.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.6.1}定义类模板}{86}{subsection.5.6.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.6.2}使用类模板}{87}{subsection.5.6.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.6.3}类模板别名}{87}{subsection.5.6.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.6.4}类模板显示特化}{87}{subsection.5.6.4}}
\@writefile{toc}{\contentsline {section}{\numberline {5.7}模版参数}{87}{section.5.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.7.1}非类型模版参数}{87}{subsection.5.7.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.7.2}默认模版参数}{88}{subsection.5.7.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.7.3}模版类型的模版参数}{88}{subsection.5.7.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.7.4}typename}{88}{subsection.5.7.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.7.5}模板类中再有模版成员}{89}{subsection.5.7.5}}
\@writefile{toc}{\contentsline {section}{\numberline {5.8}模版特化}{89}{section.5.8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.8.1}Full Specialization}{89}{subsection.5.8.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.8.2}Partial Specialization}{89}{subsection.5.8.2}}
\@writefile{toc}{\contentsline {section}{\numberline {5.9}模版友元}{89}{section.5.9}}
\@writefile{toc}{\contentsline {section}{\numberline {5.10}元编程}{90}{section.5.10}}
\@writefile{toc}{\contentsline {section}{\numberline {5.11}参考}{90}{section.5.11}}
\@writefile{toc}{\contentsline {chapter}{\numberline {第六章\hspace  {0.3em}}Effective}{91}{chapter.6}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {6.1}Effective C++}{91}{section.6.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1.1}C++ 基本相关性能提升}{91}{subsection.6.1.1}}
\@writefile{toc}{\contentsline {paragraph}{1.尽量以const，enum，inline替换\#define}{91}{section*.67}}
\@writefile{toc}{\contentsline {paragraph}{2.尽可能使用const}{91}{section*.68}}
\@writefile{toc}{\contentsline {paragraph}{3.确定对象被使用前已先被初始化}{91}{section*.69}}
\@writefile{toc}{\contentsline {subparagraph}{赋值与初始化}{91}{section*.70}}
\@writefile{toc}{\contentsline {subparagraph}{Note}{91}{section*.71}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1.2}C++ 构造/析构/赋值性能提升}{92}{subsection.6.1.2}}
\@writefile{toc}{\contentsline {paragraph}{4.C++默认编写并调用哪些函数}{92}{section*.72}}
\@writefile{toc}{\contentsline {paragraph}{5.若不想使用编译器自动生成的函数，就该明确拒绝}{92}{section*.73}}
\@writefile{toc}{\contentsline {paragraph}{6.为多态基类声明virtual析构函数}{92}{section*.74}}
\@writefile{toc}{\contentsline {paragraph}{7.别让异常逃离析构函数}{92}{section*.75}}
\@writefile{toc}{\contentsline {paragraph}{8.决不让构造和析构过程中调用virtual函数}{92}{section*.76}}
\@writefile{toc}{\contentsline {paragraph}{9.令operator= 返回一个reference to *this}{93}{section*.77}}
\@writefile{toc}{\contentsline {paragraph}{10.在operator =中处理“自我赋值”}{93}{section*.78}}
\@writefile{toc}{\contentsline {paragraph}{11.复制对象时勿忘其每一个成员}{94}{section*.79}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1.3}资源管理}{94}{subsection.6.1.3}}
\@writefile{toc}{\contentsline {paragraph}{12.以对象管理资源}{94}{section*.80}}
\@writefile{toc}{\contentsline {paragraph}{13.在资源管理类中小心拷贝行为}{94}{section*.81}}
\@writefile{toc}{\contentsline {paragraph}{14.在资源管理类中提供对原始资源的访问}{94}{section*.82}}
\@writefile{toc}{\contentsline {paragraph}{15.成对使用new和delete时要采取相同形式}{94}{section*.83}}
\@writefile{toc}{\contentsline {paragraph}{16.以独立语句将newed对象置入智能指针}{94}{section*.84}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1.4}设计与声明}{94}{subsection.6.1.4}}
\@writefile{toc}{\contentsline {paragraph}{17.让接口容易被正确使用，不易被误用}{94}{section*.85}}
\@writefile{toc}{\contentsline {paragraph}{18.设计class犹如设计type}{94}{section*.86}}
\@writefile{toc}{\contentsline {paragraph}{19.宁以pass-by-reference-to-const替代psss-by-value}{94}{section*.87}}
\@writefile{toc}{\contentsline {paragraph}{20.必须返回对象时，别妄想返回其reference}{95}{section*.88}}
\@writefile{toc}{\contentsline {paragraph}{21.将成员变量声明为private}{95}{section*.89}}
\@writefile{toc}{\contentsline {paragraph}{22.宁以non-member、non-friend替换member函数}{95}{section*.90}}
\@writefile{toc}{\contentsline {paragraph}{23.若所有参数皆需类型转换，请为此采用non-member函数}{95}{section*.91}}
\@writefile{toc}{\contentsline {paragraph}{24.考虑写出一个不抛异常的swap函数}{95}{section*.92}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1.5}实现}{95}{subsection.6.1.5}}
\@writefile{toc}{\contentsline {paragraph}{25.尽可能延后变量定义式的出现时间}{95}{section*.93}}
\@writefile{toc}{\contentsline {paragraph}{26.尽量少做转型动作}{95}{section*.94}}
\@writefile{toc}{\contentsline {paragraph}{27.避免返回handls指向对象内部成分}{95}{section*.95}}
\@writefile{toc}{\contentsline {paragraph}{28.为“异常安全”而努力是值得的}{95}{section*.96}}
\@writefile{toc}{\contentsline {paragraph}{29.透彻了解inlining的里里外外}{95}{section*.97}}
\@writefile{toc}{\contentsline {paragraph}{30.将文件间的编译依存关系降至最低}{95}{section*.98}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1.6}继承与面向对象设计}{95}{subsection.6.1.6}}
\@writefile{toc}{\contentsline {paragraph}{31.确定你的public继承塑模出is-a关系}{95}{section*.99}}
\@writefile{toc}{\contentsline {paragraph}{32.避免遮掩继承而来的名称}{95}{section*.100}}
\@writefile{toc}{\contentsline {paragraph}{33.区分接口继承和实现继承}{96}{section*.101}}
\@writefile{toc}{\contentsline {paragraph}{34.考虑virtual函数以外的其它选择}{96}{section*.102}}
\@writefile{toc}{\contentsline {paragraph}{35.绝不重新定义继承而来的non-virtual函数}{96}{section*.103}}
\@writefile{toc}{\contentsline {paragraph}{36.绝不重新定义继承而来的缺省参数值}{96}{section*.104}}
\@writefile{toc}{\contentsline {paragraph}{37.通过符合塑模出has-a或“根据某物实现出”}{96}{section*.105}}
\@writefile{toc}{\contentsline {section}{\numberline {6.2}More Effective C++}{96}{section.6.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2.1}基础议题(Basics)}{96}{subsection.6.2.1}}
\@writefile{toc}{\contentsline {paragraph}{1.仔细区别 pointers 和 references}{96}{section*.106}}
\@writefile{toc}{\contentsline {paragraph}{2.最好使用 C++ 转型操作符}{96}{section*.107}}
\@writefile{toc}{\contentsline {paragraph}{3.绝对不要以多态方式处理数组}{96}{section*.108}}
\@writefile{toc}{\contentsline {paragraph}{4.避免无用的 default constructors}{97}{section*.109}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2.2}操作符(Operators)}{97}{subsection.6.2.2}}
\@writefile{toc}{\contentsline {paragraph}{5.对定制的“类型转换函数”保持警觉}{97}{section*.110}}
\@writefile{toc}{\contentsline {subparagraph}{隐身类 类型抓换}{97}{section*.111}}
\@writefile{toc}{\contentsline {subparagraph}{避免 隐身转换}{99}{section*.112}}
\@writefile{toc}{\contentsline {paragraph}{6.区别 increment/decrement 操作符的前置和后置形式}{99}{section*.113}}
\@writefile{toc}{\contentsline {paragraph}{7.千万不要重载 \&\&, || 和 , 操作符}{99}{section*.114}}
\@writefile{toc}{\contentsline {paragraph}{8.了解各种不同意义的 new 和 delete}{99}{section*.115}}
\@writefile{toc}{\contentsline {subparagraph}{new操作符（new operator）和new操作（operator new）的区别}{99}{section*.116}}
\@writefile{toc}{\contentsline {subparagraph}{placement new}{99}{section*.117}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2.3}异常(Exceptions)}{99}{subsection.6.2.3}}
\@writefile{toc}{\contentsline {paragraph}{--堆栈辗转开解stack-unwinding}{99}{section*.118}}
\@writefile{toc}{\contentsline {paragraph}{9.利用 destructors 避免泄漏资源}{99}{section*.119}}
\@writefile{toc}{\contentsline {paragraph}{10.在 constructors 内阻止资源泄漏}{100}{section*.120}}
\@writefile{toc}{\contentsline {paragraph}{11.禁止异常流出 destructors 之外}{100}{section*.121}}
\@writefile{toc}{\contentsline {paragraph}{12.了解 "抛出一个 exception ”  与 “传递一个参数” 或 “调用一个虚函数”之间的差异}{100}{section*.122}}
\@writefile{toc}{\contentsline {paragraph}{13.以 by reference 方式捕捉 exceptions}{100}{section*.123}}
\@writefile{toc}{\contentsline {paragraph}{14.明智运用 exception specifications}{100}{section*.124}}
\@writefile{toc}{\contentsline {paragraph}{15.了解异常处理的成本}{100}{section*.125}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2.4}效率(Efficiency)}{100}{subsection.6.2.4}}
\@writefile{toc}{\contentsline {paragraph}{16.谨记 80-20 法则}{100}{section*.126}}
\@writefile{toc}{\contentsline {paragraph}{17.考虑使用 lazy evaluation（缓式评估）}{100}{section*.127}}
\@writefile{toc}{\contentsline {paragraph}{18.分期摊还预期的计算成本}{100}{section*.128}}
\@writefile{toc}{\contentsline {paragraph}{19.了解临时对象的来源}{100}{section*.129}}
\@writefile{toc}{\contentsline {paragraph}{20.协助完成“返回值优化(RVO)}{100}{section*.130}}
\@writefile{toc}{\contentsline {paragraph}{21.利用重载技术避免隐式类型转换}{100}{section*.131}}
\@writefile{toc}{\contentsline {paragraph}{22.考虑以操作符复合形式(op=)取代其独身形式(op)}{100}{section*.132}}
\@writefile{toc}{\contentsline {paragraph}{23.考虑使用其它程序库}{101}{section*.133}}
\@writefile{toc}{\contentsline {paragraph}{24.了解 virtual functions、multiple inheritance、virtual base classes、runtime type identification 的成本 }{101}{section*.134}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2.5}技术(Techniques,Idioms,Patterns)}{101}{subsection.6.2.5}}
\@writefile{toc}{\contentsline {paragraph}{25.将 constructor 和 non-member functions 虚化}{101}{section*.135}}
\@writefile{toc}{\contentsline {paragraph}{26.限制某个 class 所能产生的对象数量}{101}{section*.136}}
\@writefile{toc}{\contentsline {paragraph}{27.要求（或禁止）对象产生于 heap 中}{101}{section*.137}}
\@writefile{toc}{\contentsline {paragraph}{28.Smart Pointer（智能指针）}{101}{section*.138}}
\@writefile{toc}{\contentsline {paragraph}{29.Reference counting（引用计数）}{101}{section*.139}}
\@writefile{toc}{\contentsline {paragraph}{30.Proxy classes（替身类、代理类）}{101}{section*.140}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2.6}杂项讨论(Miscellany)}{101}{subsection.6.2.6}}
\@writefile{toc}{\contentsline {paragraph}{31.在未来时态下发展程序}{101}{section*.141}}
\@writefile{toc}{\contentsline {paragraph}{32.将非尾端类设计为抽象类}{101}{section*.142}}
\@writefile{toc}{\contentsline {section}{\numberline {6.3}Effective Modern C++}{102}{section.6.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3.1}Deducing Types}{102}{subsection.6.3.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3.2}auto}{102}{subsection.6.3.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3.3}Moving to Modern C++}{102}{subsection.6.3.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3.4}Smart Pointers}{102}{subsection.6.3.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3.5}Rvalue References, Move Semantics, and Perfect Forwarding}{102}{subsection.6.3.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3.6}Lambda Expressions}{102}{subsection.6.3.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3.7}The Concurrency API}{102}{subsection.6.3.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.3.8}Tweaks}{102}{subsection.6.3.8}}
\@writefile{toc}{\contentsline {section}{\numberline {6.4}Effective STL}{102}{section.6.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.1}容器}{102}{subsection.6.4.1}}
\@writefile{toc}{\contentsline {paragraph}{1.慎重选择容器类型，根据需要选择高效的容器类型}{102}{section*.143}}
\@writefile{toc}{\contentsline {paragraph}{2.不要试图编写独立于容器类型的代码}{102}{section*.144}}
\@writefile{toc}{\contentsline {paragraph}{3.确定容器中的对象拷贝正确而高效。也就是防止在存在继承关系时发生剥离}{102}{section*.145}}
\@writefile{toc}{\contentsline {paragraph}{4.调用empty而不是检查size()是否为0来判断容器是否为空}{102}{section*.146}}
\@writefile{toc}{\contentsline {paragraph}{5.尽量使用区间成员，而不是多次使用与之对应的单元素成员函数，原因是这样更加高效}{102}{section*.147}}
\@writefile{toc}{\contentsline {paragraph}{6.小心C++编译器最烦人的分析机制}{102}{section*.148}}
\@writefile{toc}{\contentsline {paragraph}{7.如果在容器中包含了能过new操作创建的指针，切记在容器对象析构前将指针delete掉}{102}{section*.149}}
\@writefile{toc}{\contentsline {paragraph}{\sout  {8.切勿创建包含auto\_ptr的容器对象}}{102}{section*.150}}
\@writefile{toc}{\contentsline {paragraph}{9.慎重选择删除元素的方法}{103}{section*.151}}
\@writefile{toc}{\contentsline {paragraph}{10.了解分配器allocator的约定和限制}{103}{section*.152}}
\@writefile{toc}{\contentsline {paragraph}{11.理解自定义分配器合理用法}{103}{section*.153}}
\@writefile{toc}{\contentsline {paragraph}{12.切勿对STL容器的线程安全性有不切实际的依赖}{103}{section*.154}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.2}vector And string}{103}{subsection.6.4.2}}
\@writefile{toc}{\contentsline {paragraph}{13.尽量用vector和string代替动态分配的数组}{103}{section*.155}}
\@writefile{toc}{\contentsline {paragraph}{14.使用reserve来避免不必要的内存重新分配}{103}{section*.156}}
\@writefile{toc}{\contentsline {paragraph}{15.注意string实现的多样性}{103}{section*.157}}
\@writefile{toc}{\contentsline {paragraph}{16.了解如何把vector和string数据传给旧的C API}{103}{section*.158}}
\@writefile{toc}{\contentsline {paragraph}{17.使用“swap 技巧”除去多余的容量}{103}{section*.159}}
\@writefile{toc}{\contentsline {paragraph}{18.避免使用vector<bool>}{103}{section*.160}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.3}关联容器}{103}{subsection.6.4.3}}
\@writefile{toc}{\contentsline {paragraph}{19.理解相等equality 和等价equivalence 的区别}{103}{section*.161}}
\@writefile{toc}{\contentsline {paragraph}{20.为包含指针的关联容器指定比较类型}{103}{section*.162}}
\@writefile{toc}{\contentsline {paragraph}{21.总是让比较函数在等值情况下返回false}{104}{section*.163}}
\@writefile{toc}{\contentsline {paragraph}{22.切勿直接修改set 或 multiset中的键}{104}{section*.164}}
\@writefile{toc}{\contentsline {paragraph}{23.考虑用排序的vector 替代 关联容器}{104}{section*.165}}
\@writefile{toc}{\contentsline {paragraph}{24.当效率至关重要时，请在map::operator[]与map::insert之间做出谨慎选择}{104}{section*.166}}
\@writefile{toc}{\contentsline {paragraph}{25.熟悉散列容器}{104}{section*.167}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.4}迭代器}{104}{subsection.6.4.4}}
\@writefile{toc}{\contentsline {paragraph}{26.尽量使用iterator，而不是const\_iterator、reverse\_iterator及const\_reverse\_iterator}{104}{section*.168}}
\@writefile{toc}{\contentsline {paragraph}{27.使用distance和advance将容器的const\_iterator转换成iterator}{104}{section*.169}}
\@writefile{toc}{\contentsline {paragraph}{28.正确理解由reverse\_iterator的base()成员函数所产生的iterator的用法}{104}{section*.170}}
\@writefile{toc}{\contentsline {paragraph}{29.对非格式化的逐个字符的输入考虑使用 istreambuf\_iterator}{104}{section*.171}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.5}算法}{104}{subsection.6.4.5}}
\@writefile{toc}{\contentsline {paragraph}{30.确保目标区间足够大}{104}{section*.172}}
\@writefile{toc}{\contentsline {paragraph}{31.了解各种与排序有关的选择}{104}{section*.173}}
\@writefile{toc}{\contentsline {subparagraph}{非稳定排序}{105}{section*.174}}
\@writefile{toc}{\contentsline {subparagraph}{稳定排序}{105}{section*.175}}
\@writefile{toc}{\contentsline {subparagraph}{分割序列的算法}{105}{section*.176}}
\@writefile{toc}{\contentsline {paragraph}{32.如果确实需要删除元素，则需要在remove这一类算法之后调用成员函数erase}{105}{section*.177}}
\@writefile{toc}{\contentsline {paragraph}{33.对包含指针的容器使用remove这一类算法时要特别小心}{105}{section*.178}}
\@writefile{toc}{\contentsline {paragraph}{\sout  {34.了解哪些算法要求使用排序区间作为参数}}{105}{section*.179}}
\@writefile{toc}{\contentsline {paragraph}{\sout  {35.通过mismatch或lexicographical\_compare实现简单忽略大小写的字符串比较}}{105}{section*.180}}
\@writefile{toc}{\contentsline {paragraph}{36.理解copy\_if算法的正确实现}{105}{section*.181}}
\@writefile{toc}{\contentsline {paragraph}{37. 使用accumulate或者for\_each进行区间统计}{105}{section*.182}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.6}函数子、函数子类、函数及其他}{105}{subsection.6.4.6}}
\@writefile{toc}{\contentsline {paragraph}{38.遵循按值传递的原则来设计函数子类}{105}{section*.183}}
\@writefile{toc}{\contentsline {paragraph}{39.确保判别式predicate是纯函数pure function}{105}{section*.184}}
\@writefile{toc}{\contentsline {paragraph}{40.若一个类是函数子，则就使它可配接adaptable}{105}{section*.185}}
\@writefile{toc}{\contentsline {paragraph}{41.理解ptr\_fun、mem\_fun、mem\_fun\_ref的来由}{106}{section*.186}}
\@writefile{toc}{\contentsline {paragraph}{42.确保 less<T>与operator< 具有相同的语义}{106}{section*.187}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.4.7}在程序中使用STL}{106}{subsection.6.4.7}}
\@writefile{toc}{\contentsline {paragraph}{43.算法调用优先于手写的循环}{106}{section*.188}}
\@writefile{toc}{\contentsline {paragraph}{44.容器的成员函数优于同名的算法}{106}{section*.189}}
\@writefile{toc}{\contentsline {paragraph}{45.正确区分 count、find、binary\_search、lower\_bound、upper\_bound 和 equal\_range}{106}{section*.190}}
\@writefile{toc}{\contentsline {paragraph}{46.考虑使用函数对象而不是函数作为STL算法参数}{106}{section*.191}}
\@writefile{toc}{\contentsline {paragraph}{47.避免产生“直写型（write-only）”代码}{107}{section*.192}}
\@writefile{toc}{\contentsline {paragraph}{48.总是包含（\#include）正确的头文件}{107}{section*.193}}
\@writefile{toc}{\contentsline {paragraph}{49.学会分析与STL相关的编译器诊断信息}{107}{section*.194}}
\@writefile{toc}{\contentsline {section}{\numberline {6.5}提升C++编程性能的技术}{107}{section.6.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.1}跟踪范例}{107}{subsection.6.5.1}}
\@writefile{toc}{\contentsline {subparagraph}{关注点}{107}{section*.195}}
\@writefile{toc}{\contentsline {subparagraph}{解决方案}{107}{section*.196}}
\@writefile{toc}{\contentsline {subparagraph}{涉及技术- 延迟创建}{107}{section*.197}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.2}虚函数}{108}{subsection.6.5.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.3}临时对象}{108}{subsection.6.5.3}}
\@writefile{toc}{\contentsline {subparagraph}{关注点}{108}{section*.198}}
\@writefile{toc}{\contentsline {subparagraph}{类型不匹配}{108}{section*.199}}
\@writefile{toc}{\contentsline {subparagraph}{避免重复创建相同的临时对象}{108}{section*.200}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.4}内存池}{108}{subsection.6.5.4}}
\@writefile{toc}{\contentsline {subsubsection}{单线程内存池}{108}{section*.201}}
\@writefile{toc}{\contentsline {subparagraph}{关注点}{108}{section*.202}}
\@writefile{toc}{\contentsline {subparagraph}{Rational 专用内存池}{108}{section*.203}}
\@writefile{toc}{\contentsline {subparagraph}{固定大小内存池实现}{109}{section*.204}}
\@writefile{toc}{\contentsline {subparagraph}{不定大小内存池}{110}{section*.205}}
\@writefile{toc}{\contentsline {subsubsection}{多线程内存池}{110}{section*.206}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.5}引用计数}{110}{subsection.6.5.5}}
\@writefile{toc}{\contentsline {subparagraph}{关注点}{110}{section*.207}}
\@writefile{toc}{\contentsline {subparagraph}{引用计数的实现}{110}{section*.208}}
\@writefile{toc}{\contentsline {subparagraph}{并发引用计数}{111}{section*.209}}
\@writefile{toc}{\contentsline {subparagraph}{引用计数的性能}{111}{section*.210}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.6}代码优化}{112}{subsection.6.5.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.7}设计优化}{112}{subsection.6.5.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.8}可伸缩性}{112}{subsection.6.5.8}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.5.9}系统体系结构相关性}{112}{subsection.6.5.9}}
\@writefile{toc}{\contentsline {section}{\numberline {6.6}深入探索 C++ 对象模型}{112}{section.6.6}}
\@writefile{toc}{\contentsline {section}{\numberline {6.7}STL 源码剖析}{112}{section.6.7}}
\@writefile{toc}{\contentsline {section}{\numberline {6.8}参考}{112}{section.6.8}}
\@writefile{toc}{\contentsline {paragraph}{Effective C++}{112}{section*.211}}
\@writefile{toc}{\contentsline {paragraph}{More Effective C++}{112}{section*.212}}
\@writefile{toc}{\contentsline {paragraph}{Effective Mordern C++}{112}{section*.213}}
\@writefile{toc}{\contentsline {paragraph}{Effective STL}{112}{section*.214}}
\@writefile{toc}{\contentsline {paragraph}{提高C++性能的编程技术}{112}{section*.215}}
\@writefile{toc}{\contentsline {paragraph}{STL 源码剖析}{112}{section*.216}}
\@writefile{toc}{\contentsline {chapter}{\numberline {第七章\hspace  {0.3em}}OpenMP 并行技术}{113}{chapter.7}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {chapter}{\numberline {第八章\hspace  {0.3em}}GPU 并行技术}{115}{chapter.8}}
\@writefile{lof}{\addvspace {10\p@ }}
\@writefile{lot}{\addvspace {10\p@ }}
\@writefile{toc}{\contentsline {section}{\numberline {8.1}OpenCL}{115}{section.8.1}}
\@writefile{toc}{\contentsline {section}{\numberline {8.2}CUDA}{115}{section.8.2}}
