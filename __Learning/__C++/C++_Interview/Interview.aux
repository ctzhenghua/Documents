\relax 
\providecommand\hyper@newdestlabel[2]{}
\providecommand\HyperFirstAtBeginDocument{\AtBeginDocument}
\HyperFirstAtBeginDocument{\ifx\hyper@anchor\@undefined
\global\let\oldcontentsline\contentsline
\gdef\contentsline#1#2#3#4{\oldcontentsline{#1}{#2}{#3}}
\global\let\oldnewlabel\newlabel
\gdef\newlabel#1#2{\newlabelxx{#1}#2}
\gdef\newlabelxx#1#2#3#4#5#6{\oldnewlabel{#1}{{#2}{#3}}}
\AtEndDocument{\ifx\hyper@anchor\@undefined
\let\contentsline\oldcontentsline
\let\newlabel\oldnewlabel
\fi}
\fi}
\global\let\hyper@last\relax 
\gdef\HyperFirstAtBeginDocument#1{#1}
\providecommand*\HyPL@Entry[1]{}
\HyPL@Entry{0<</S/D>>}
\@writefile{toc}{\contentsline {section}{\numberline {1}参考学习网址}{4}{section.1}}
\@writefile{toc}{\contentsline {section}{\numberline {2}Linux}{5}{section.2}}
\@writefile{toc}{\contentsline {subsection}{\numberline {2.1}题目}{5}{subsection.2.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.1}熟练netstat tcpdump ipcs ipcrm}{5}{subsubsection.2.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.2}共享内存段被映射进进程空间之后，存在于进程空间的什么位置？共享内存段}{5}{subsubsection.2.1.2}}
\@writefile{toc}{\contentsline {subparagraph}{共享内存定义}{5}{section*.2}}
\@writefile{toc}{\contentsline {subparagraph}{共享内存的使用实现原理}{5}{section*.3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.3}进程内存空间分布情况}{5}{subsubsection.2.1.3}}
\@writefile{toc}{\contentsline {subparagraph}{内核空间和用户空间}{5}{section*.4}}
\@writefile{toc}{\contentsline {subparagraph}{用户空间布局}{5}{section*.5}}
\@writefile{toc}{\contentsline {subparagraph}{多线程程序与普通程序的内存布局的不同}{6}{section*.6}}
\@writefile{toc}{\contentsline {subparagraph}{其他细节}{6}{section*.7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.4}ELF是什么？其大小与程序中全局变量的是否初始化有什么关系}{6}{subsubsection.2.1.4}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.5}动态链接和静态链接的区别？}{6}{subsubsection.2.1.5}}
\@writefile{toc}{\contentsline {subparagraph}{静态库与动态库}{6}{section*.8}}
\@writefile{toc}{\contentsline {subparagraph}{静态库与导入库的区别}{7}{section*.9}}
\@writefile{toc}{\contentsline {subparagraph}{动态链接与静态链接}{7}{section*.10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.6}32位系统一个进程最多有多少堆内存}{7}{subsubsection.2.1.6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.7}写一个c程序辨别系统是大端or小端字节序}{7}{subsubsection.2.1.7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.8}信号：列出常见的信号，信号怎么处理？}{7}{subsubsection.2.1.8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.9}i++ 是否原子操作?并解释为什么?}{7}{subsubsection.2.1.9}}
\@writefile{toc}{\contentsline {subparagraph}{原子操作}{7}{section*.11}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.10}说出你所知道的各类linux系统的各类同步机制（重点），什么是死锁？如何避免死锁}{8}{subsubsection.2.1.10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.11}如何实现守护进程？}{8}{subsubsection.2.1.11}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.12}linux的任务调度机制是什么？}{8}{subsubsection.2.1.12}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.13}标准库函数和系统调用的区别？}{8}{subsubsection.2.1.13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.14}系统如何将一个信号通知到进程？}{8}{subsubsection.2.1.14}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.15}fork()一子进程程后父进程的全局变量能不能使用？}{8}{subsubsection.2.1.15}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.16}多线程与多进程的区别}{8}{subsubsection.2.1.16}}
\@writefile{toc}{\contentsline {subparagraph}{线程安全的条件}{8}{section*.12}}
\@writefile{toc}{\contentsline {subparagraph}{关于线程的堆栈}{8}{section*.13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.17}多线程的各种锁！}{8}{subsubsection.2.1.17}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.18}缓存淘汰算法-LRU}{8}{subsubsection.2.1.18}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.19}可重入与不可重入}{9}{subsubsection.2.1.19}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.20}crontab原理}{9}{subsubsection.2.1.20}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.21}*coreDump}{9}{subsubsection.2.1.21}}
\@writefile{toc}{\contentsline {subparagraph}{概念}{9}{section*.14}}
\@writefile{toc}{\contentsline {subparagraph}{coreDump 文件}{9}{section*.15}}
\@writefile{toc}{\contentsline {subparagraph}{如何判断一个文件是coredump文件}{9}{section*.16}}
\@writefile{toc}{\contentsline {subparagraph}{coredump产生的几种可能情况}{9}{section*.17}}
\@writefile{toc}{\contentsline {subparagraph}{利用gdb进行coredump的定位}{10}{section*.18}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {2.1.22}线程达到线程池定义个数，怎么办}{10}{subsubsection.2.1.22}}
\@writefile{toc}{\contentsline {section}{\numberline {3}C++}{11}{section.3}}
\@writefile{toc}{\contentsline {subsection}{\numberline {3.1}题目}{11}{subsection.3.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.1}文本文件和二进制文件的区别}{11}{subsubsection.3.1.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.2}结构体用memcmp比较的问题}{11}{subsubsection.3.1.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.3}memcpy 实现}{11}{subsubsection.3.1.3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.4}strcpy 实现}{11}{subsubsection.3.1.4}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.5}strcat 实现}{11}{subsubsection.3.1.5}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.6}书写 给定类的赋值操作符 = }{11}{subsubsection.3.1.6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.7}什么是“引用”？申明和使用“引用”要注意哪些问题？}{11}{subsubsection.3.1.7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.8}将“引用”作为函数参数有哪些特点？}{12}{subsubsection.3.1.8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.9}在什么时候需要使用“常引用”？}{12}{subsubsection.3.1.9}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.10}将“引用”作为函数返回值类型的格式、好处和需要遵守的规则?}{12}{subsubsection.3.1.10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.11}引用与指针的区别是什么？}{12}{subsubsection.3.1.11}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.12}什么时候需要“引用”？}{12}{subsubsection.3.1.12}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.13}结构与联合有和区别？}{13}{subsubsection.3.1.13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.14} 已知strcpy的函数原型：char *strcpy(char *strDest, const char *strSrc)其中strDest 是目的字符串，strSrc 是源字符串。不调用C++/C 的字符串库函数，请编写函数 strcpy}{13}{subsubsection.3.1.14}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.15}不用中间变量实现交换swap的问题}{13}{subsubsection.3.1.15}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.16}＃include<file.h> 与＃include "file.h"的区别？}{13}{subsubsection.3.1.16}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.17}面向对象的三个基本特征，并简单叙述之？}{13}{subsubsection.3.1.17}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.18}重载（overload)和重写(overried，有的书也叫做“覆盖”）的区别？}{13}{subsubsection.3.1.18}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.19}多态的作用？}{14}{subsubsection.3.1.19}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.20}virtual 指针与对象初始化的区别}{14}{subsubsection.3.1.20}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.21}New delete 与malloc free 的联系与区别?}{14}{subsubsection.3.1.21}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.22}有哪几种情况只能用intializationlist 而不能用assignment?}{14}{subsubsection.3.1.22}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.23}C++是不是类型安全的？}{14}{subsubsection.3.1.23}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.24}指针函数与函数指针}{14}{subsubsection.3.1.24}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.25}请说出const与\#define 相比，有何优点？}{15}{subsubsection.3.1.25}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.26}简述数组与指针的区别？}{15}{subsubsection.3.1.26}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.27}类成员函数的重载、覆盖和隐藏区别？}{15}{subsubsection.3.1.27}}
\@writefile{toc}{\contentsline {subparagraph}{成员函数被重载的特征}{15}{section*.19}}
\@writefile{toc}{\contentsline {subparagraph}{覆盖是指派生类函数覆盖基类函数，特征是}{15}{section*.20}}
\@writefile{toc}{\contentsline {subparagraph}{“隐藏”是指派生类的函数屏蔽了与其同名的基类函数，规则如下}{16}{section*.21}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.28}如何打印出当前源文件的文件名以及源文件的当前行号？}{16}{subsubsection.3.1.28}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.29}关于\_\_stdcall和\_\_cdecl调用方式的理解}{16}{subsubsection.3.1.29}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {3.1.30}腾讯-输出是什么 }{16}{subsubsection.3.1.30}}
\@writefile{toc}{\contentsline {section}{\numberline {4}STL 组件与使用}{17}{section.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.1}题目}{17}{subsection.4.1}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {4.1.1}使用过哪些组件？}{17}{subsubsection.4.1.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {4.2}体会}{17}{subsection.4.2}}
\@writefile{toc}{\contentsline {section}{\numberline {5}Boost 组件与使用}{18}{section.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {5.1}题目}{18}{subsection.5.1}}
\@writefile{toc}{\contentsline {subparagraph}{boost 的网络库ASIO}{18}{section*.22}}
\@writefile{toc}{\contentsline {section}{\numberline {6}网络、服务器编程}{19}{section.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.1}参考C++\_NetProgram}{19}{subsection.6.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {6.2}题目}{19}{subsection.6.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.1}多线程和多进程的区别}{19}{subsubsection.6.2.1}}
\@writefile{toc}{\contentsline {subparagraph}{线程所私有的}{19}{section*.23}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.2}多线程锁的种类有哪些？}{19}{subsubsection.6.2.2}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.3}自旋锁和互斥锁的区别？}{19}{subsubsection.6.2.3}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.4}进程间通信和线程间通信}{19}{subsubsection.6.2.4}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.5}多线程程序架构，线程数量应该如何设置？}{19}{subsubsection.6.2.5}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.6}什么是原子操作，gcc提供的原子操作原语，使用这些原语如何实现读写锁？}{19}{subsubsection.6.2.6}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.7}网络编程设计模式，reactor/proactor/半同步半异步模式？}{19}{subsubsection.6.2.7}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.8}有一个计数器，多个线程都需要更新，会遇到什么问题，原因是什么，应该如何做？如何优化？}{20}{subsubsection.6.2.8}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.9}如果select返回可读，结果只读到0字节，什么情况？}{20}{subsubsection.6.2.9}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.10}connect可能会长时间阻塞，怎么解决?}{20}{subsubsection.6.2.10}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.11}keepalive 是什么东西？如何使用？}{20}{subsubsection.6.2.11}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.12}socket什么情况下可读？}{20}{subsubsection.6.2.12}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.13}udp调用connect有什么作用？}{20}{subsubsection.6.2.13}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.14}socket编程，如果client断电了，服务器如何快速知道？}{20}{subsubsection.6.2.14}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.15}怎么清理僵尸进程}{20}{subsubsection.6.2.15}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.16}系统调用函数}{20}{subsubsection.6.2.16}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.17}socket 的阻塞和非阻塞的概念}{20}{subsubsection.6.2.17}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.18}信号与信号量之间的区别}{20}{subsubsection.6.2.18}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.19}TCP头大小，包含字段？三次握手，四次断开描述过程，都有些什么状态。状态变迁图。TCP/IP收发缓冲区}{20}{subsubsection.6.2.19}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.20}使用udp和tcp进程网络传输，为什么tcp能保证包是发送顺序，而 udp无法保证？}{20}{subsubsection.6.2.20}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.21}epoll哪些触发模式，有啥区别？}{20}{subsubsection.6.2.21}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.22}tcp与udp的区别（必问）为什么TCP要叫做数据流？}{20}{subsubsection.6.2.22}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.23}流量控制和拥塞控制的实现机制}{20}{subsubsection.6.2.23}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.24}滑动窗口的实现机制}{20}{subsubsection.6.2.24}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.25}epoll和select的区别？}{21}{subsubsection.6.2.25}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.26}网络中，如果客户端突然掉线或者重启，服务器端怎么样才能立刻知道？}{21}{subsubsection.6.2.26}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.27}TTL是什么？有什么用处，通常那些工具会用到它？ping? traceroute? ifconfig? netstat?}{21}{subsubsection.6.2.27}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.28}linux的五种IO模式/异步模式.}{21}{subsubsection.6.2.28}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.29}请说出http协议的优缺点.}{21}{subsubsection.6.2.29}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.30}NAT类型，UDP穿透原理}{21}{subsubsection.6.2.30}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.31}大规模连接上来，并发模型怎么设计}{21}{subsubsection.6.2.31}}
\@writefile{toc}{\contentsline {subsubsection}{\numberline {6.2.32}流量控制与拥塞控制的区别，节点计算机怎样感知网络拥塞了？}{21}{subsubsection.6.2.32}}
\@writefile{toc}{\contentsline {section}{\numberline {7}多线程编程}{22}{section.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {7.1}参考C++\_Advanced}{22}{subsection.7.1}}
\@writefile{toc}{\contentsline {section}{\numberline {8}算法}{23}{section.8}}
\@writefile{toc}{\contentsline {section}{\numberline {9}程序设计}{24}{section.9}}
\@writefile{toc}{\contentsline {subsection}{\numberline {9.1}设计模式}{24}{subsection.9.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {9.2}UML}{24}{subsection.9.2}}
\@writefile{toc}{\contentsline {section}{\numberline {10}OpenGL}{25}{section.10}}
\@writefile{toc}{\contentsline {subsection}{\numberline {10.1}参考OpenGL}{25}{subsection.10.1}}
\@writefile{toc}{\contentsline {section}{\numberline {11}DirectX}{26}{section.11}}
\@writefile{toc}{\contentsline {subsection}{\numberline {11.1}参考DirectX9}{26}{subsection.11.1}}
\@writefile{toc}{\contentsline {section}{\numberline {12}PC游戏试玩记录}{27}{section.12}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.1}坦克世界}{27}{subsection.12.1}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.2}生死狙击}{27}{subsection.12.2}}
\@writefile{toc}{\contentsline {paragraph}{连跳}{27}{section*.24}}
\@writefile{toc}{\contentsline {paragraph}{升级跳}{27}{section*.25}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.3}Dota2}{27}{subsection.12.3}}
\@writefile{toc}{\contentsline {paragraph}{1.起步-新手}{27}{section*.26}}
\@writefile{toc}{\contentsline {paragraph}{2.准备-新玩}{27}{section*.27}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.4}CrossFire}{27}{subsection.12.4}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.5}League Of Legends}{27}{subsection.12.5}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.6}文明5}{27}{subsection.12.6}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.7}极品飞车-系列}{27}{subsection.12.7}}
\@writefile{toc}{\contentsline {subsection}{\numberline {12.8}QQ飞车--鹏鹏卡丁车}{27}{subsection.12.8}}
